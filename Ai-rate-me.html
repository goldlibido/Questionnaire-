<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>🔥 Hot or Not AI 🔥</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0"></script>
<script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

<style>
  html, body {
    margin: 0;
    padding: 0;
    background: black;
    overflow: hidden;
    font-family: Arial, sans-serif;
    color: white;
  }
  video, canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
  }
  #overlay {
    pointer-events: none;
  }
  .bottomPanel {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    background: rgba(0,0,0,0.4);
    padding: 15px 20px;
    border-radius: 15px;
    backdrop-filter: blur(10px);
    opacity: 0;
    transition: opacity 1s ease;
  }
  .glow { animation: glowPulse 1s infinite alternate; }
  @keyframes glowPulse {
    from { text-shadow: 0 0 5px #fff, 0 0 10px #ff4d6d; }
    to { text-shadow: 0 0 15px #fff, 0 0 25px #ff4d6d; }
  }
</style>
</head>
<body>

<video id="camera" autoplay muted playsinline></video>
<canvas id="overlay"></canvas>

<div class="bottomPanel" id="resultsPanel">
  <div id="vibeText"></div>
  <div id="typeText"></div>
  <div id="badgeText"></div>
  <div id="rankText"></div>
</div>

<script>
let faceModel, bodyModel, detector, video, canvas, ctx;
let scorePhase = 0; // 0=waiting, 1=face, 2=body, 3=done
let faceScoreFinal = 0, bodyScoreFinal = 0;
let tickerScore = 0;
let faceBox = null;
const vibes = ["Confident Charmer 😎","Playful Energy 😜","Mysterious Allure 🖤","Romantic Dreamer 💖","Adventurous Spirit 🌍","Life of the Party 🎉"];
const roastTypes = [
  "People who treat red flags as decorative lights 🚩",
  "Girls who would date a SoundCloud rapper *on purpose* 🎤",
  "Guys who think foreplay is playing Xbox before bed 🎮",
  "People who ghost but still watch your stories 👻",
  "Women who have 4 exes and they’re all DJs 🎧",
  "Men who post gym selfies with captions about 'the grind' 💪"
];
const badges = ["Certified Heartbreaker 💔","Main Character Energy 🎬","Dangerously Hot 🔥","Chaos in Human Form 🌪️","Too Hot to Handle 🚫🔥"];
function randomRank(){ return `Top ${Math.floor(Math.random()*50)+1}% of uploads today`; }

async function loadModels() {
  await faceapi.nets.ssdMobilenetv1.loadFromUri('https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js/models');
  faceModel = await tf.loadLayersModel('https://huggingface.co/datasets/ayasy/face_beauty_tfjs/resolve/main/model.json');
  bodyModel = faceModel;
  detector = await poseDetection.createDetector(poseDetection.SupportedModels.BlazePose, { runtime: 'tfjs', modelType: 'full' });
}

async function initCamera() {
  video = document.getElementById('camera');
  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
  video.srcObject = stream;
  await new Promise(res => video.onloadedmetadata = res);
}

async function detectFrame() {
  const detections = await faceapi.detectSingleFace(video);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if (detections) {
    faceBox = detections.box;
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.lineWidth = 2;
    ctx.strokeRect(faceBox.x, faceBox.y, faceBox.width, faceBox.height);

    // Draw ticker above head
    const tickerY = faceBox.y - 20;
    ctx.font = "28px Arial";
    ctx.fillStyle = "#ff4d6d";
    ctx.textAlign = "center";
    let label = "";
    if (scorePhase === 1) label = `Face: ${tickerScore.toFixed(1)}/10`;
    if (scorePhase === 2) label = `Body: ${tickerScore.toFixed(1)}/10`;
    if (label) ctx.fillText(label, faceBox.x + faceBox.width/2, tickerY);
  }
  requestAnimationFrame(detectFrame);
}

async function scoreSequence() {
  const cropFace = document.createElement('canvas');
  cropFace.width = 400; cropFace.height = 400;
  if (faceBox) {
    cropFace.getContext('2d').drawImage(video, faceBox.x, faceBox.y, faceBox.width, faceBox.height, 0, 0, 400, 400);
    faceScoreFinal = await predictScore(cropFace, faceModel);
  }
  const poses = await detector.estimatePoses(video);
  if (poses.length) {
    const xs = poses[0].keypoints.map(k=>k.x), ys = poses[0].keypoints.map(k=>k.y);
    const box = { x: Math.min(...xs), y: Math.min(...ys), width: Math.max(...xs)-Math.min(...xs), height: Math.max(...ys)-Math.min(...ys) };
    const cropBody = document.createElement('canvas');
    cropBody.width = 400; cropBody.height = 400;
    cropBody.getContext('2d').drawImage(video, box.x, box.y, box.width, box.height, 0, 0, 400, 400);
    bodyScoreFinal = await predictScore(cropBody, bodyModel);
  }
  // Animate Face
  scorePhase = 1;
  await animateTicker(faceScoreFinal);
  // Animate Body
  scorePhase = 2;
  await animateTicker(bodyScoreFinal);
  // Show final panel
  scorePhase = 3;
  document.getElementById("vibeText").innerText = `Vibe: ${vibes[Math.floor(Math.random()*vibes.length)]}`;
  document.getElementById("typeText").innerText = `Type: ${roastTypes[Math.floor(Math.random()*roastTypes.length)]}`;
  document.getElementById("badgeText").innerText = `🏆 ${badges[Math.floor(Math.random()*badges.length)]}`;
  document.getElementById("rankText").innerText = randomRank();
  document.getElementById("resultsPanel").style.opacity = 1;
  confetti();
}

async function animateTicker(finalScore) {
  return new Promise(res=>{
    tickerScore = 0.0;
    const step = finalScore / 40;
    const intv = setInterval(()=>{
      tickerScore += step;
      if (tickerScore >= finalScore) {
        tickerScore = finalScore;
        clearInterval(intv);
        res();
      }
    },50);
  });
}

async function predictScore(canvas, model) {
  const t = tf.browser.fromPixels(canvas).resizeBilinear([224,224]).toFloat().div(tf.scalar(255)).expandDims(0);
  const p = model.predict(t), s = await p.data();
  t.dispose(); p.dispose();
  return Math.max(1, Math.min(10, s[0])).toFixed(1);
}

(async ()=>{
  await loadModels();
  await initCamera();
  canvas = document.getElementById('overlay');
  ctx = canvas.getContext('2d');
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  detectFrame();
  setTimeout(scoreSequence, 2000); // Give time for camera to settle
})();
</script>

</body>
</html>