<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Le Libido ‚Äî Audio Pickup Editor</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700;800&display=swap" rel="stylesheet">
<style>
  :root{ --gold:#e1bf78; --blue:#064D95; --green:#06954E; --red:#950606; --bg:#0d0d0d; --card:#151515; --muted:#b9b9b9; }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:var(--bg);font-family:Montserrat,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:#fff}
  .border-wrap{min-height:100vh;padding:2px;background:linear-gradient(100deg,var(--red),var(--blue),var(--green))}
  .app{min-height:calc(100vh - 4px);background:var(--bg);display:flex;flex-direction:column;align-items:center}
  header{width:100%;padding:22px 16px 8px;text-align:center}
  header img{width:120px;height:auto;display:block;margin:0 auto 10px;filter:drop-shadow(0 0 10px rgba(225,191,120,.25))}
  .title{font-weight:800;letter-spacing:.5px;font-size:clamp(20px,3vw,28px);text-shadow:0 0 8px rgba(225,191,120,.25)}
  .steps{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;padding:6px 16px 14px;width:100%}
  .step-pill{padding:8px 12px;border:1px solid rgba(225,191,120,.3);border-radius:999px;color:#fff;font-weight:600;font-size:12px;opacity:.6;user-select:none}
  .step-pill.active{opacity:1;border-color:var(--gold);box-shadow:0 0 14px rgba(225,191,120,.2) inset}
  .panel{width:min(1100px,94vw);background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:18px;margin:10px auto 28px;box-shadow:0 25px 60px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.02)}
  .panel h2{margin:6px 8px 14px;font-size:18px;font-weight:800;letter-spacing:.3px}
  .grid{display:grid;gap:14px} .grid.cols-2{grid-template-columns:1fr 1fr} @media (max-width:800px){.grid.cols-2{grid-template-columns:1fr}}
  .btn{appearance:none;border:0;border-radius:12px;padding:14px 18px;background:linear-gradient(180deg,#1e1e1e,#121212);color:#fff;font-weight:700;letter-spacing:.3px;cursor:pointer;border:1px solid rgba(255,255,255,.08);transition:.2s transform,.2s box-shadow,.2s background}
  .btn:hover{transform:translateY(-1px);box-shadow:0 8px 24px rgba(0,0,0,.35)}
  .btn.gold{background:linear-gradient(180deg,#f4d796,#c9a760);color:#111;border:1px solid #d7b56f;text-shadow:0 1px 0 rgba(255,255,255,.35)}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,.18)}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center} .hidden{display:none !important}
  label{font-size:12px;color:#e5e5e5;margin-bottom:6px;display:block}
  input[type="text"],select{width:100%;padding:12px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:#111;color:#fff;outline:none;font-size:14px;touch-action:manipulation}
  input[type="range"]{flex:1}
  .rec-wrap{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.01));border:1px dashed rgba(255,255,255,.15);border-radius:14px;padding:16px}
  .record-btn{width:160px;height:160px;border-radius:999px;border:1px solid rgba(255,255,255,.15);cursor:pointer;background:radial-gradient(closest-side, rgba(225,191,120,.25) 0%, rgba(225,191,120,0) 78%),linear-gradient(180deg,#272727,#161616);color:#fff;font-weight:800;font-size:15px;letter-spacing:.5px;box-shadow:0 20px 60px rgba(0,0,0,.45),0 0 0 6px rgba(225,191,120,.08) inset}
  .rec-indicator{width:10px;height:10px;background:#f34a4a;border-radius:50%;box-shadow:0 0 12px rgba(243,74,74,.9);display:inline-block;margin-right:8px;vertical-align:middle;animation:pulse 1s infinite}
  @keyframes pulse{0%{transform:scale(1);opacity:1}50%{transform:scale(1.3);opacity:.65}100%{transform:scale(1);opacity:1}}
  .player{display:flex;align-items:center;gap:12px;margin-top:14px}
  .play-toggle{width:46px;height:46px;border-radius:50%;border:1px solid rgba(255,255,255,.15);background:#151515;color:#fff;font-weight:800;cursor:pointer}
  .bar{flex:1;height:10px;background:#0f0f0f;border-radius:999px;position:relative;border:1px solid rgba(255,255,255,.1);overflow:hidden;cursor:pointer}
  .bar .fill{position:absolute;inset:0 100% 0 0;background:linear-gradient(90deg,var(--red),var(--blue),var(--green));border-right:2px solid rgba(255,255,255,.5)}
  .time{font-size:12px;color:var(--muted);width:74px;text-align:right}
  .editor-wrap{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.01));border:1px dashed rgba(255,255,255,.15);border-radius:14px;padding:16px;margin-top:16px}
  .timeline{position:relative;height:180px;background:#0f0f0f;border:1px solid rgba(255,255,255,.1);border-radius:8px;overflow:hidden}
  .timeline canvas{width:100%;height:100%}
  .segments-container{position:absolute;top:0;left:0;width:100%;height:100%;overflow:visible}
  .segment{position:absolute;height:30px;background:rgba(225,191,120,.2);border:1px solid var(--gold);cursor:move;opacity:0.7;top:calc(var(--layer) * 35px);transition:opacity .2s}
  .segment:hover{opacity:1}
  .segment.effect{background:rgba(6,149,78,.2);border-color:var(--green)}
  .segment .volume-control{position:absolute;top:-30px;left:0;width:100px;padding:4px;background:#151515;border:1px solid rgba(255,255,255,.15);border-radius:8px;display:none}
  .segment:hover .volume-control{display:block}
  .effects{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  .effect-btn{padding:6px 10px;border-radius:999px;background:#151515;border:1px solid rgba(255,255,255,.15);cursor:pointer;font-size:12px;color:#fff}
  .effect-item{padding:6px;border-radius:8px;background:rgba(0,0,0,.5);cursor:grab;border:1px solid rgba(255,255,255,.2);margin:5px;position:relative}
  .effect-item .delete{position:absolute;top:-5px;right:-5px;background:var(--red);color:#fff;border-radius:50%;width:15px;height:15px;line-height:15px;text-align:center;cursor:pointer;font-size:10px}
  .deck{position:relative;height:420px;border-radius:16px;overflow:hidden;background:#0f0f10;border:1px solid rgba(255,255,255,.08)}
  .card{position:absolute;inset:0;padding:18px;display:flex;flex-direction:column;justify-content:flex-end;background:radial-gradient(1200px 500px at 100% -10%, rgba(255,255,255,.06), transparent 70%),linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01))}
  .swipe-actions{display:flex;gap:10px}
  .pass,.like{flex:1;padding:12px 14px;border-radius:10px;font-weight:800;border:1px solid rgba(255,255,255,.12);cursor:pointer}
  .pass{background:#151515;color:#ddd}
  .like{background:linear-gradient(180deg,#f4d796,#bf9a55);color:#111}
  .match-modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6);z-index:50}
  .match-box{width:min(520px,92vw);background:#121212;border:1px solid rgba(255,255,255,.12);border-radius:16px;padding:18px;text-align:center}
  .chat{height:420px;display:flex;flex-direction:column;border-radius:12px;overflow:hidden;border:1px solid rgba(255,255,255,.1);background:#0f0f10}
  .chat-log{flex:1;overflow:auto;padding:14px;display:flex;flex-direction:column;gap:10px}
  .bubble{max-width:78%;padding:10px 12px;border-radius:12px;font-size:14px;line-height:1.35}
  .me{align-self:flex-end;background:#172015;border:1px solid rgba(225,191,120,.25)}
  .them{align-self:flex-start;background:#141414;border:1px solid rgba(255,255,255,.12)}
  .composer{display:flex;gap:8px;padding:10px;border-top:1px solid rgba(255,255,255,.08);background:#101010}
  .composer input[type="text"]{flex:1;background:#0f0f0f;border:1px solid rgba(255,255,255,.12)}
  .small{font-size:12px;color:var(--muted)} .tip{color:var(--muted);font-size:12px;margin-top:6px}
  .param-row{display:flex;gap:8px;align-items:center;margin-top:8px}
  .snap-line{position:absolute;top:0;bottom:0;width:1px;background:rgba(225,191,120,.5);display:none}
</style>
</head>
<body>
<div class="border-wrap">
  <div class="app">
    <header>
      <img src="golden-le-libido-logo.png" alt="Le Libido" onerror="this.style.opacity=0">
      <div class="title">Blind Audio Pickup</div>
      <div class="small">Craft your pickup line with effects. Match to unlock chats.</div>
    </header>

    <div class="steps" id="stepper">
      <div class="step-pill active">1 ‚Ä¢ Record & Edit</div>
      <div class="step-pill">2 ‚Ä¢ Swipe</div>
      <div class="step-pill">3 ‚Ä¢ Chat</div>
    </div>

    <!-- STEP 1: Record & Edit -->
    <section class="panel" id="step1">
      <h2>Step 1 ‚Äî Craft your pickup line</h2>
      <div class="grid cols-2">
        <div class="rec-wrap">
          <div class="row" style="align-items:center; justify-content:center; gap:18px; margin-bottom:12px">
            <button class="btn" id="undoBtn">Undo</button>
            <button class="btn" id="redoBtn">Redo</button>
            <button class="btn" id="aiAmazeBtn">AI Amazement</button>
          </div>
          <div class="row" style="align-items:center; justify-content:center; gap:18px; margin-bottom:12px">
            <button class="record-btn" id="recordBtn"><span id="recLabel">Start Recording</span></button>
            <div>
              <div class="small">Tap to record, edit with effects, keep under 15s.</div>
              <div class="tip">Use HTTPS and allow mic permission.</div>
            </div>
          </div>
          <div id="playerBlock" class="hidden">
            <div class="player">
              <button class="play-toggle" id="playToggle">‚ñ∂</button>
              <div class="bar" id="seekBar"><div class="fill" id="fill"></div></div>
              <div class="time" id="time">0:00</div>
            </div>
            <div class="row" style="margin-top:10px">
              <button class="btn ghost" id="retakeBtn">Retake</button>
            </div>
            <audio id="audio" preload="metadata" class="hidden"></audio>
          </div>
          <div id="editorBlock" class="editor-wrap hidden">
            <h3>Edit Your Pickup</h3>
            <div class="timeline" id="timeline">
              <canvas id="timelineCanvas"></canvas>
              <div id="segmentsContainer" class="segments-container"></div>
              <div id="snapLine" class="snap-line"></div>
            </div>
            <div class="effects">
              <button class="effect-btn" data-effect="echo">Echo</button>
              <div class="param-row hidden" id="echoParams">
                <label>Delay:</label><input type="range" min="0.1" max="1" step="0.1" value="0.3" id="echoDelay">
                <label>Decay:</label><input type="range" min="0.1" max="0.9" step="0.1" value="0.5" id="echoDecay">
              </div>
              <button class="effect-btn" data-effect="pitchUp">Pitch Up</button>
              <div class="param-row hidden" id="pitchParams">
                <label>Amount:</label><input type="range" min="0.5" max="2" step="0.1" value="1.2" id="pitchAmount">
              </div>
              <button class="effect-btn" id="cutBtn">Cut Selection</button>
            </div>
            <div class="row" style="margin-top:10px">
              <button class="btn" id="recordSoundBtn">Record New Sound</button>
              <button class="btn" id="uploadSoundBtn">Upload Sound</button>
              <input type="file" id="soundFileInput" accept="audio/*" class="hidden">
              <div id="effectsList" class="effects" style="flex:1;"></div>
            </div>
            <div class="row" style="margin-top:10px">
              <button class="btn gold" id="saveEditBtn">Save & Swipe ‚Üí</button>
            </div>
          </div>
        </div>
        <div class="rec-wrap">
          <strong>Great pickup lines are:</strong>
          <ul style="margin-top:8px; color:#ddd; line-height:1.5">
            <li>Short, playful, creative with effects</li>
            <li>Flirty and fun, not cheesy</li>
            <li>Unique with sounds or vibe</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- STEP 2: Swipe -->
    <section class="panel hidden" id="step2">
      <h2>Step 2 ‚Äî Swipe pickup lines</h2>
      <div class="deck" id="deck"></div>
      <div class="tip">Hear creative lines. Like to match and unlock chats.</div>
    </section>

    <!-- STEP 3: Chat -->
    <section class="panel hidden" id="step3">
      <h2>Private Chat</h2>
      <div class="chat" id="chat">
        <div class="chat-log" id="chatLog"></div>
        <div class="composer">
          <input type="text" id="chatInput" placeholder="Type a message‚Ä¶" />
          <input type="file" id="chatPhoto" accept="image/*" class="hidden">
          <button class="btn" id="chatPhotoBtn">üì∑</button>
          <button class="btn" id="chatVoiceBtn">üéôÔ∏è</button>
          <button class="btn" id="callBtn">üìû</button>
          <button class="btn gold" id="chatSendBtn">Send</button>
        </div>
        <div class="tip">Send texts, pics, voice memos, or start a voice call.</div>
      </div>
    </section>

    <!-- MATCH MODAL -->
    <div class="match-modal" id="matchModal" role="dialog" aria-modal="true">
      <div class="match-box">
        <h3>It‚Äôs a Match!</h3>
        <p>You both liked each other‚Äôs pickup line. Chat unlocked!</p>
        <div class="row" style="justify-content:center">
          <button class="btn ghost" id="closeMatch">Keep Swiping</button>
          <button class="btn gold" id="openChat">Open Chat</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Firebase + App logic -->
<script type="module">
  /***** FIREBASE IMPORTS *****/
  import { app, db } from './firebase-config.js';
  import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js';
  import { getStorage, ref as sRef, uploadBytes, getDownloadURL } from 'https://www.gstatic.com/firebasejs/10.12.3/firebase-storage.js';
  import { ref as rRef, set, get, onValue, push, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js';

  const auth = getAuth(app);
  const storage = getStorage(app);

  let currentUser = null;
  try { await signInAnonymously(auth); } catch (e) { console.error('Anon sign-in failed', e); }
  onAuthStateChanged(auth, u => { currentUser = u || null; });

  /***** BASIC NAV / STEP UI *****/
  const $ = s => document.querySelector(s);
  const $$ = s => document.querySelectorAll(s);
  const stepper = $('#stepper').children;
  function go(i) {
    ['#step1', '#step2', '#step3'].forEach((id, idx) => {
      const el = $(id);
      if (idx === i) { el.classList.remove('hidden'); stepper[idx].classList.add('active'); }
      else { el.classList.add('hidden'); stepper[idx].classList.remove('active'); }
    });
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }
  Array.from(stepper).forEach((pill, idx) => {
    pill.style.cursor = 'pointer';
    pill.addEventListener('click', () => {
      if (idx === 1 && !window.__recBlob) { alert('Record and edit your pickup line first.'); return; }
      if (idx === 2 && !window.__activeRoom) { alert('Open a match from the deck to chat.'); return; }
      go(idx);
      if (idx === 1 && !window.__deckInit) initDeck();
    });
  });

  /***** RECORDING *****/
  const recordBtn = $('#recordBtn'), recLabel = $('#recLabel');
  const audioEl = $('#audio'), playerBlock = $('#playerBlock');
  const playToggle = $('#playToggle'), seekBar = $('#seekBar'), fill = $('#fill'), time = $('#time');
  const retakeBtn = $('#retakeBtn'), saveEditBtn = $('#saveEditBtn');
  const undoBtn = $('#undoBtn'), redoBtn = $('#redoBtn'), aiAmazeBtn = $('#aiAmazeBtn');
  let mediaRecorder, recChunks = [], recStream = null, recMime = '', recording = false;
  window.__recBlob = null;

  function supportedMime() {
    const c = ['audio/webm;codecs=opus', 'audio/mp4;codecs=aac', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/mp4', 'audio/aac'];
    for (const t of c) { if (window.MediaRecorder?.isTypeSupported?.(t)) return t; }
    return '';
  }
  async function startRecording() {
    try {
      recMime = supportedMime();
      recStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(recStream, recMime ? { mimeType: recMime } : undefined);
      recChunks = [];
      mediaRecorder.ondataavailable = e => { if (e.data?.size) recChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        window.__recBlob = new Blob(recChunks, { type: recMime || 'audio/webm' });
        const url = URL.createObjectURL(window.__recBlob);
        audioEl.src = url;
        playerBlock.classList.remove('hidden');
        document.getElementById('editorBlock').classList.remove('hidden');
        initEditor(url);
      };
      mediaRecorder.start();
      recording = true;
      recLabel.innerHTML = '<span class="rec-indicator"></span> Recording‚Ä¶';
    } catch (err) { alert('Mic permission needed. Use HTTPS.'); console.error(err); }
  }
  function stopRecording() {
    if (mediaRecorder && recording) {
      mediaRecorder.stop();
      recStream?.getTracks().forEach(t => t.stop());
      recording = false;
      recLabel.textContent = 'Start Recording';
    }
  }
  recordBtn.addEventListener('click', () => recording ? stopRecording() : startRecording());

  const fmt = s => { s = Math.floor(s); const m = Math.floor(s / 60), r = s % 60; return `${m}:${r.toString().padStart(2, '0')}`; };
  function updateTime(c, d) { time.textContent = `${fmt(c)} / ${d ? fmt(d) : '0:00'}`; }
  playToggle.addEventListener('click', () => {
    if (audioEl.paused) { audioEl.play(); playToggle.textContent = '‚è∏'; } else { audioEl.pause(); playToggle.textContent = '‚ñ∂'; }
  });
  audioEl.addEventListener('pause', () => playToggle.textContent = '‚ñ∂');
  audioEl.addEventListener('play', () => playToggle.textContent = '‚è∏');
  audioEl.addEventListener('timeupdate', () => {
    const d = audioEl.duration || 0, c = audioEl.currentTime || 0, pct = d ? (c / d) * 100 : 0;
    fill.style.inset = `0 ${100 - pct}% 0 0`;
    updateTime(c, d);
  });
  seekBar.addEventListener('click', e => {
    const r = seekBar.getBoundingClientRect();
    const x = (e.clientX - r.left) / r.width;
    if (audioEl.duration) audioEl.currentTime = x * audioEl.duration;
  });
  retakeBtn.addEventListener('click', () => {
    if (!audioEl.paused) audioEl.pause();
    playerBlock.classList.add('hidden');
    document.getElementById('editorBlock').classList.add('hidden');
    window.__recBlob = null;
    audioEl.removeAttribute('src');
    segments = [];
    sounds = [];
    history = [];
    historyIndex = -1;
    $('#effectsList').innerHTML = '';
    $('#segmentsContainer').innerHTML = '';
    timelineCanvas.getContext('2d').clearRect(0, 0, timelineCanvas.width, timelineCanvas.height);
    selectedStart = selectedEnd = null;
  });

  /***** AUDIO EDITOR *****/
  let audioCtx, timelineCanvas = $('#timelineCanvas');
  let segments = []; // [{id, start: seconds, duration: seconds, buffer, type: 'main' or 'sound', layer: 0+, volume: 0-1, soundId}]
  let sounds = []; // [{id, name, buffer}]
  let soundCounter = 0;
  let segmentCounter = 0;
  let selectedStart = null, selectedEnd = null; // selection in pct
  let history = [];
  let historyIndex = -1;
  const maxLayers = 5;

  async function initEditor(url) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const resp = await fetch(url);
    const arrayBuf = await resp.arrayBuffer();
    const buffer = await audioCtx.decodeAudioData(arrayBuf);
    segments = [{id: segmentCounter++, start: 0, duration: buffer.duration, buffer, type: 'main', layer: 0, volume: 1.0}];
    pushHistory();
    updateSegmentsUI();
    drawWaveform();
    setupTimelineEvents();
    setupSoundDragDrop();
  }

  function pushHistory() {
    history = history.slice(0, historyIndex + 1);
    history.push(JSON.parse(JSON.stringify(segments.map(s => ({...s, buffer: null})))));
    historyIndex = history.length - 1;
  }

  undoBtn.addEventListener('click', async () => {
    if (historyIndex <= 0) return;
    historyIndex--;
    const targetState = history[historyIndex];
    segments = await Promise.all(targetState.map(async s => {
      if (s.type === 'main') {
        const mainSeg = segments.find(seg => seg.type === 'main');
        return {...s, buffer: mainSeg.buffer};
      } else {
        const sound = sounds.find(snd => snd.id === s.soundId);
        return {...s, buffer: sound.buffer};
      }
    }));
    updateSegmentsUI();
    drawWaveform();
    updatePreview();
  });

  redoBtn.addEventListener('click', async () => {
    if (historyIndex >= history.length - 1) return;
    historyIndex++;
    const targetState = history[historyIndex];
    segments = await Promise.all(targetState.map(async s => {
      if (s.type === 'main') {
        const mainSeg = segments.find(seg => seg.type === 'main');
        return {...s, buffer: mainSeg.buffer};
      } else {
        const sound = sounds.find(snd => snd.id === s.soundId);
        return {...s, buffer: sound.buffer};
      }
    }));
    updateSegmentsUI();
    drawWaveform();
    updatePreview();
  });

  function drawWaveform() {
    const canvas = timelineCanvas;
    canvas.width = canvas.offsetWidth * 2; // HiDPI
    canvas.height = canvas.offsetHeight * 2;
    const ctx = canvas.getContext('2d');
    ctx.scale(2, 2);
    const width = canvas.offsetWidth;
    const height = canvas.offsetHeight;
    ctx.clearRect(0, 0, width, height);

    const maxDuration = segments.reduce((max, seg) => Math.max(max, seg.start + seg.duration), 0) || 1;
    segments.forEach(seg => {
      const data = seg.buffer.getChannelData(0);
      const samples = Math.floor(width * (seg.duration / maxDuration));
      const blockSize = Math.floor(data.length / samples) || 1;
      const filteredData = [];
      for (let i = 0; i < samples; i++) {
        let sum = 0;
        for (let j = 0; j < blockSize; j++) {
          sum += Math.abs(data[blockSize * i + j] || 0);
        }
        filteredData.push(sum / blockSize);
      }
      const multiplier = Math.pow(Math.max(...filteredData, 1), -1);
      const normalizedData = filteredData.map(n => n * multiplier);

      const startX = (seg.start / maxDuration) * width;
      const segHeight = 30;
      const yOffset = seg.layer * 35 + 5;
      ctx.beginPath();
      ctx.moveTo(startX, yOffset + segHeight / 2);
      for (let i = 0; i < samples; i++) {
        const x = startX + i * (width * (seg.duration / maxDuration) / samples);
        const y = yOffset + (1 - normalizedData[i]) * (segHeight / 2);
        ctx.lineTo(x, y);
      }
      for (let i = samples - 1; i >= 0; i--) {
        const x = startX + i * (width * (seg.duration / maxDuration) / samples);
        const y = yOffset + (1 + normalizedData[i]) * (segHeight / 2);
        ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fillStyle = seg.type === 'main' ? 'rgba(225,191,120,.5)' : 'rgba(6,149,78,.5)';
      ctx.fill();
    });
  }

  function updateSegmentsUI() {
    const container = $('#segmentsContainer');
    container.innerHTML = '';
    const timelineWidth = timelineCanvas.offsetWidth;
    const maxDuration = segments.reduce((max, seg) => Math.max(max, seg.start + seg.duration), 0) || 1;
    segments.forEach(seg => {
      const div = document.createElement('div');
      div.className = `segment ${seg.type === 'sound' ? 'effect' : ''}`;
      div.dataset.id = seg.id;
      div.style.left = `${(seg.start / maxDuration) * 100}%`;
      div.style.width = `${(seg.duration / maxDuration) * 100}%`;
      div.style.setProperty('--layer', seg.layer);
      const volControl = document.createElement('div');
      volControl.className = 'volume-control';
      volControl.innerHTML = `<input type="range" min="0" max="1" step="0.01" value="${seg.volume}" class="volume-slider">`;
      div.appendChild(volControl);
      container.appendChild(div);
      makeDraggable(div, maxDuration);
      volControl.querySelector('.volume-slider').addEventListener('input', e => {
        seg.volume = parseFloat(e.target.value);
        updatePreview();
        pushHistory();
      });
    });
  }

  function makeDraggable(el, maxDuration) {
    let startX, startLeft, startWidth, startLayer, resizeDir = null;
    el.addEventListener('mousedown', e => {
      if (e.offsetX < 10) resizeDir = 'left';
      else if (e.offsetX > el.offsetWidth - 10) resizeDir = 'right';
      else resizeDir = null;
      startX = e.clientX;
      startLeft = parseFloat(el.style.left) || 0;
      startWidth = parseFloat(el.style.width) || 0;
      startLayer = parseInt(el.style.getPropertyValue('--layer')) || 0;
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
      // Handle layer change on right-click or long press
      el.addEventListener('contextmenu', e => {
        e.preventDefault();
        const seg = segments.find(s => s.id == el.dataset.id);
        seg.layer = (seg.layer + 1) % maxLayers;
        el.style.setProperty('--layer', seg.layer);
        pushHistory();
      });
    });
    function onMove(e) {
      const deltaPct = ((e.clientX - startX) / timelineCanvas.offsetWidth) * 100;
      if (resizeDir === 'left') {
        const newLeft = Math.max(0, startLeft + deltaPct);
        el.style.left = `${newLeft}%`;
        el.style.width = `${startWidth - (newLeft - startLeft)}%`;
      } else if (resizeDir === 'right') {
        el.style.width = `${Math.max(0, startWidth + deltaPct)}%`;
      } else {
        el.style.left = `${Math.max(0, startLeft + deltaPct)}%`;
      }
    }
    function onUp() {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      updateSegmentFromUI(el);
      drawWaveform();
      pushHistory();
    }
  }

  function updateSegmentFromUI(el) {
    const maxDuration = segments.reduce((max, seg) => Math.max(max, seg.start + seg.duration), 0) || 1;
    const leftPct = parseFloat(el.style.left) / 100;
    const widthPct = parseFloat(el.style.width) / 100;
    const seg = segments.find(s => s.id == el.dataset.id);
    if (seg) {
      seg.start = leftPct * maxDuration;
      seg.duration = widthPct * maxDuration;
      if (resizeDir) {
        seg.buffer = sliceBuffer(seg.buffer, 0, seg.duration * seg.buffer.sampleRate);
      }
    }
    updatePreview();
  }

  function setupTimelineEvents() {
    const canvas = timelineCanvas;
    let isSelecting = false;
    let startX;
    canvas.addEventListener('mousedown', e => {
      isSelecting = true;
      startX = e.offsetX / canvas.offsetWidth;
    });
    canvas.addEventListener('mousemove', e => {
      if (isSelecting) {
        // Visual feedback for selection could be added
      }
    });
    canvas.addEventListener('mouseup', e => {
      if (isSelecting) {
        const endX = e.offsetX / canvas.offsetWidth;
        selectedStart = Math.min(startX, endX);
        selectedEnd = Math.max(startX, endX);
        isSelecting = false;
      }
    });
  }

  $('#cutBtn').addEventListener('click', () => {
    if (selectedStart === null || selectedEnd === null) return alert('Select a range on the timeline first.');
    const maxDuration = segments.reduce((max, seg) => Math.max(max, seg.start + seg.duration), 0) || 1;
    const cutStartTime = selectedStart * maxDuration;
    const cutEndTime = selectedEnd * maxDuration;
    let newSegments = [];
    segments.forEach(seg => {
      if (cutEndTime <= seg.start || cutStartTime >= seg.start + seg.duration) {
        newSegments.push(seg);
      } else {
        if (cutStartTime > seg.start) {
          const leftDuration = cutStartTime - seg.start;
          const leftBuffer = sliceBuffer(seg.buffer, 0, leftDuration * seg.buffer.sampleRate);
          newSegments.push({id: segmentCounter++, start: seg.start, duration: leftDuration, buffer: leftBuffer, type: seg.type, layer: seg.layer, volume: seg.volume});
        }
        if (cutEndTime < seg.start + seg.duration) {
          const rightStart = cutEndTime;
          const rightDuration = (seg.start + seg.duration) - cutEndTime;
          const rightOffset = (rightStart - seg.start) * seg.buffer.sampleRate;
          const rightBuffer = sliceBuffer(seg.buffer, rightOffset, rightDuration * seg.buffer.sampleRate);
          newSegments.push({id: segmentCounter++, start: rightStart, duration: rightDuration, buffer: rightBuffer, type: seg.type, layer: seg.layer, volume: seg.volume});
        }
      }
    });
    segments = newSegments;
    updateSegmentsUI();
    drawWaveform();
    updatePreview();
    pushHistory();
    selectedStart = selectedEnd = null;
  });

  function sliceBuffer(buffer, startSample, durationSamples) {
    const newBuffer = audioCtx.createBuffer(buffer.numberOfChannels, durationSamples, buffer.sampleRate);
    for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
      newBuffer.copyToChannel(buffer.getChannelData(ch).subarray(startSample, startSample + durationSamples), ch);
    }
    return newBuffer;
  }

  document.querySelectorAll('.effect-btn:not(#cutBtn)').forEach(btn => {
    btn.addEventListener('click', async () => {
      const effect = btn.dataset.effect;
      const paramsDiv = $(`#${effect}Params`);
      paramsDiv.classList.toggle('hidden');
      if (!paramsDiv.classList.contains('hidden')) return;
      const maxDuration = segments.reduce((max, seg) => Math.max(max, seg.start + seg.duration), 0) || 1;
      const selStartTime = selectedStart ? selectedStart * maxDuration : null;
      const selEndTime = selectedEnd ? selectedEnd * maxDuration : null;
      for (let i = 0; i < segments.length; i++) {
        if (!selStartTime || (segments[i].start < selEndTime && segments[i].start + segments[i].duration > selStartTime)) {
          let params = {};
          if (effect === 'echo') {
            params = { delay: parseFloat($('#echoDelay').value), decay: parseFloat($('#echoDecay').value) };
          } else if (effect === 'pitchUp') {
            params = { amount: parseFloat($('#pitchAmount').value) };
          }
          segments[i].buffer = await applyEffectToBuffer(segments[i].buffer, effect, params);
        }
      }
      updatePreview();
      drawWaveform();
      pushHistory();
    });
  });

  async function applyEffectToBuffer(buffer, effect, params) {
    if (effect === 'echo') {
      return await applyEcho(buffer, params.delay, params.decay);
    } else if (effect === 'pitchUp') {
      return await applyPitchShift(buffer, params.amount);
    }
    return buffer;
  }

  async function applyEcho(buffer, delay, decay) {
    const offlineCtx = new OfflineAudioContext(buffer.numberOfChannels, buffer.length * 1.5, buffer.sampleRate);
    const source = offlineCtx.createBufferSource();
    source.buffer = buffer;
    const delayNode = offlineCtx.createDelay(delay);
    const gainNode = offlineCtx.createGain();
    gainNode.gain.value = decay;
    source.connect(delayNode);
    delayNode.connect(gainNode);
    gainNode.connect(offlineCtx.destination);
    gainNode.connect(delayNode);
    source.connect(offlineCtx.destination);
    source.start();
    return await offlineCtx.startRendering();
  }

  async function applyPitchShift(buffer, rate) {
    const offlineCtx = new OfflineAudioContext(buffer.numberOfChannels, buffer.length * (1 / rate), buffer.sampleRate);
    const source = offlineCtx.createBufferSource();
    source.buffer = buffer;
    source.playbackRate.value = rate;
    source.connect(offlineCtx.destination);
    source.start();
    return await offlineCtx.startRendering();
  }

  let soundRecorder, soundChunks = [], soundStream;
  $('#recordSoundBtn').addEventListener('click', async () => {
    if (!soundRecorder) {
      try {
        soundStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        soundRecorder = new MediaRecorder(soundStream);
        soundChunks = [];
        soundRecorder.ondataavailable = e => soundChunks.push(e.data);
        soundRecorder.onstop = async () => {
          const blob = new Blob(soundChunks, { type: 'audio/webm' });
          const url = URL.createObjectURL(blob);
          const resp = await fetch(url);
          const arrayBuf = await resp.arrayBuffer();
          const buf = await audioCtx.decodeAudioData(arrayBuf);
          const id = soundCounter++;
          sounds.push({id, name: `Sound ${id + 1}`, buffer: buf});
          addSoundUI(id, `Sound ${id + 1}`);
        };
        soundRecorder.start();
        $('#recordSoundBtn').textContent = 'Stop Recording Sound';
      } catch (err) { alert('Mic access needed.'); }
    } else {
      soundRecorder.stop();
      soundStream.getTracks().forEach(t => t.stop());
      soundRecorder = null;
      $('#recordSoundBtn').textContent = 'Record New Sound';
    }
  });

  $('#uploadSoundBtn').addEventListener('click', () => $('#soundFileInput').click());
  $('#soundFileInput').addEventListener('change', async e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async ev => {
      try {
        const buf = await audioCtx.decodeAudioData(ev.target.result);
        const id = soundCounter++;
        sounds.push({id, name: file.name, buffer: buf});
        addSoundUI(id, file.name);
      } catch (err) { alert('Invalid audio file.'); }
    };
    reader.readAsArrayBuffer(file);
  });

  function addSoundUI(id, name) {
    const list = $('#effectsList');
    const div = document.createElement('div');
    div.className = 'effect-item';
    div.draggable = true;
    div.textContent = name;
    div.dataset.id = id;
    const delBtn = document.createElement('span');
    delBtn.className = 'delete';
    delBtn.textContent = '√ó';
    delBtn.addEventListener('click', () => {
      if (confirm('Are you sure you want to delete this sound? It will be permanently erased.')) {
        sounds = sounds.filter(s => s.id !== id);
        segments = segments.filter(s => s.soundId !== id);
        div.remove();
        updateSegmentsUI();
        drawWaveform();
        updatePreview();
        pushHistory();
      }
    });
    div.appendChild(delBtn);
    list.appendChild(div);
    div.addEventListener('dragstart', e => {
      e.dataTransfer.setData('soundId', id);
    });
  }

  function setupSoundDragDrop() {
    const timeline = $('#timeline');
    const snapLine = $('#snapLine');
    let dropLayer = 0;
    timeline.addEventListener('dragenter', e => e.preventDefault());
    timeline.addEventListener('dragover', e => {
      e.preventDefault();
      const rect = timeline.getBoundingClientRect();
      const dropX = e.clientX - rect.left;
      const maxDuration = segments.reduce((max, seg) => Math.max(max, seg.start + seg.duration), 0) || 1;
      const dropTime = Math.round((dropX / rect.width) * maxDuration * 10) / 10; // Snap to 0.1s
      snapLine.style.left = `${(dropTime / maxDuration) * 100}%`;
      snapLine.style.display = 'block';
      dropLayer = Math.floor(e.offsetY / 35);
      if (dropLayer >= maxLayers) dropLayer = maxLayers - 1;
    });
    timeline.addEventListener('dragleave', () => {
      snapLine.style.display = 'none';
    });
    timeline.addEventListener('drop', async e => {
      e.preventDefault();
      snapLine.style.display = 'none';
      const soundId = e.dataTransfer.getData('soundId');
      const sound = sounds.find(s => s.id == soundId);
      if (!sound) return;
      const rect = timeline.getBoundingClientRect();
      const dropX = e.clientX - rect.left;
      const maxDuration = segments.reduce((max, seg) => Math.max(max, seg.start + seg.duration), 0) || 1;
      const dropTime = Math.round((dropX / rect.width) * maxDuration * 10) / 10; // Snap to 0.1s
      segments.push({
        id: segmentCounter++,
        start: dropTime,
        duration: sound.buffer.duration,
        buffer: sound.buffer,
        type: 'sound',
        layer: dropLayer,
        volume: 1.0,
        soundId
      });
      updateSegmentsUI();
      drawWaveform();
      updatePreview();
      pushHistory();
    });
  }

  async function updatePreview() {
    const mixedBuffer = await renderMixedBuffer();
    const blob = await audioBufferToBlob(mixedBuffer);
    audioEl.src = URL.createObjectURL(blob);
  }

  async function renderMixedBuffer() {
    const maxDuration = segments.reduce((max, seg) => Math.max(max, seg.start + seg.duration), 0) || 1;
    const length = Math.ceil(maxDuration * audioCtx.sampleRate);
    const offlineCtx = new OfflineAudioContext(2, length, audioCtx.sampleRate);
    segments.forEach(seg => {
      const source = offlineCtx.createBufferSource();
      source.buffer = seg.buffer;
      const gainNode = offlineCtx.createGain();
      gainNode.gain.value = seg.volume;
      source.connect(gainNode);
      gainNode.connect(offlineCtx.destination);
      source.start(seg.start);
    });
    return await offlineCtx.startRendering();
  }

  async function audioBufferToBlob(buffer) {
    const offlineCtx = new OfflineAudioContext(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
    const src = offlineCtx.createBufferSource();
    src.buffer = buffer;
    src.connect(offlineCtx.destination);
    src.start();
    const rendered = await offlineCtx.startRendering();
    const wav = await audioBufferToWav(rendered);
    return new Blob([wav], { type: 'audio/wav' });
  }

  async function audioBufferToWav(buffer) {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const length = buffer.length * numChannels * 2 + 44;
    const arrayBuffer = new ArrayBuffer(length);
    const view = new DataView(arrayBuffer);

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    let offset = 0;
    writeString(view, offset, 'RIFF'); offset += 4;
    view.setUint32(offset, 36 + buffer.length * numChannels * 2, true); offset += 4;
    writeString(view, offset, 'WAVE'); offset += 4;
    writeString(view, offset, 'fmt '); offset += 4;
    view.setUint32(offset, 16, true); offset += 4;
    view.setUint16(offset, 1, true); offset += 2;
    view.setUint16(offset, numChannels, true); offset += 2;
    view.setUint32(offset, sampleRate, true); offset += 4;
    view.setUint32(offset, sampleRate * numChannels * 2, true); offset += 4;
    view.setUint16(offset, numChannels * 2, true); offset += 2;
    view.setUint16(offset, 16, true); offset += 2;
    writeString(view, offset, 'data'); offset += 4;
    view.setUint32(offset, buffer.length * numChannels * 2, true); offset += 4;

    for (let i = 0; i < buffer.length; i++) {
      for (let ch = 0; ch < numChannels; ch++) {
        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(ch)[i]));
        view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
        offset += 2;
      }
    }
    return arrayBuffer;
  }

  aiAmazeBtn.addEventListener('click', () => {
    alert('AI Amazement feature coming soon! Add your OpenAI API key to enable transcription and smart sound placement.');
  });

  saveEditBtn.addEventListener('click', async () => {
    if (segments.length === 0) { alert('Record and edit your pickup line first.'); return; }
    const mixedBuffer = await renderMixedBuffer();
    window.__recBlob = await audioBufferToBlob(mixedBuffer);
    const lineRef = sRef(storage, `lines/${currentUser.uid}/${Date.now()}.wav`);
    await uploadBytes(lineRef, window.__recBlob, { contentType: 'audio/wav' });
    const lineURL = await getDownloadURL(lineRef);
    await set(rRef(db, `lines/${currentUser.uid}`), { uid: currentUser.uid, lineURL, ts: serverTimestamp() });
    go(1);
    initDeck();
  });

  /***** SWIPE: AUDIO LINES *****/
  const deckEl = $('#deck');
  let deck = [], deckIdx = 0;
  window.__deckInit = false;

  function listenLines() {
    const pRef = rRef(db, 'lines');
    onValue(pRef, snap => {
      const all = snap.val() || {};
      deck = Object.values(all).filter(p => p.uid !== currentUser?.uid && p.lineURL);
      deckIdx = 0;
      renderCard();
    });
  }

  function initDeck() {
    if (window.__deckInit) return;
    window.__deckInit = true;
    listenLines();
  }

  async function renderCard() {
    deckEl.innerHTML = '';
    if (!deck.length || deckIdx >= deck.length) {
      const empty = document.createElement('div');
      empty.className = 'card';
      empty.innerHTML = `<h3>${deck.length ? 'That‚Äôs all for now' : 'No lines yet'}</h3>
        <div class="small">${deck.length ? 'New pickup lines appear as more people join.' : 'Be the first‚Äîshare your link!'}</div>`;
      deckEl.appendChild(empty);
      return;
    }
    const p = deck[deckIdx];
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `
      <div class="small">üéß Listen to their creative pickup line.</div>
      <div class="rec-wrap">
        <div class="player">
          <button class="play-toggle">‚ñ∂</button>
          <div class="bar"><div class="fill"></div></div>
          <div class="time">0:00</div>
        </div>
        <audio preload="metadata" class="hidden"></audio>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="pass">Pass</button>
        <button class="like">Like</button>
      </div>`;
    deckEl.appendChild(card);

    const audio = card.querySelector('audio');
    audio.src = p.lineURL;
    const playBtn = card.querySelector('.play-toggle');
    const bar = card.querySelector('.bar');
    const fill = card.querySelector('.fill');
    const tm = card.querySelector('.time');
    playBtn.addEventListener('click', () => { if (audio.paused) { audio.play(); playBtn.textContent = '‚è∏'; } else { audio.pause(); playBtn.textContent = '‚ñ∂'; } });
    audio.addEventListener('pause', () => playBtn.textContent = '‚ñ∂');
    audio.addEventListener('play', () => playBtn.textContent = '‚è∏');
    audio.addEventListener('timeupdate', () => {
      const d = audio.duration || 0, c = audio.currentTime || 0, pct = d ? (c / d) * 100 : 0;
      fill.style.inset = `0 ${100 - pct}% 0 0`;
      tm.textContent = `${fmt(c)} / ${d ? fmt(d) : '0:00'}`;
    });
    bar.addEventListener('click', e => {
      const r = bar.getBoundingClientRect();
      const x = (e.clientX - r.left) / r.width;
      if (audio.duration) audio.currentTime = x * audio.duration;
    });

    card.querySelector('.pass').addEventListener('click', () => { audio.pause(); deckIdx++; renderCard(); });
    card.querySelector('.like').addEventListener('click', () => { audio.pause(); handleLike(p.uid); });
  }

  /***** MATCHING *****/
  function pairIdFor(a, b) { return [a, b].sort().join('_'); }

  async function handleLike(themUid) {
    const me = currentUser.uid;
    const myLikeRef = rRef(db, `likes/${me}/${themUid}`);
    const theirLikeRef = rRef(db, `likes/${themUid}/${me}`);

    await set(myLikeRef, true);
    const theirLikeSnap = await get(theirLikeRef);
    const matched = !!theirLikeSnap.val();

    if (!matched) { deckIdx++; renderCard(); return; }

    const pid = pairIdFor(me, themUid);
    const pairRef = rRef(db, `pairs/${pid}`);
    const pairSnap = await get(pairRef);

    if (!pairSnap.exists()) {
      await set(pairRef, { id: pid, a: me, b: themUid, roomId: pid, ts: serverTimestamp() });
      await set(rRef(db, `rooms/${pid}`), { id: pid, a: me, b: themUid, created: serverTimestamp() });
    }

    showMatch(pid);
  }

  function showMatch(roomId) {
    const m = $('#matchModal');
    m.style.display = 'flex';
    $('#closeMatch').onclick = () => { m.style.display = 'none'; deckIdx++; renderCard(); };
    $('#openChat').onclick = () => { m.style.display = 'none'; openChat(roomId); };
  }

  /***** CHAT (Realtime DB + Storage + WebRTC) *****/
  let activeRoom = null;
  window.__activeRoom = null;
  let messagesUnsub = null;
  let peerConnection = null;

  function pushBubble(who, content, type = 'text') {
    const log = $('#chatLog');
    const b = document.createElement('div');
    b.className = `bubble ${who}`;
    if (type === 'text') { b.textContent = content; }
    if (type === 'image') { const img = document.createElement('img'); img.src = content; img.style.maxWidth = '100%'; b.appendChild(img); }
    if (type === 'audio') { const a = document.createElement('audio'); a.controls = true; a.src = content; b.appendChild(a); }
    log.appendChild(b);
    log.scrollTop = log.scrollHeight;
  }

  function openChat(roomId) {
    activeRoom = roomId;
    window.__activeRoom = roomId;
    $('#chatLog').innerHTML = '';
    go(2);

    const msgsRef = rRef(db, `rooms/${roomId}/messages`);
    if (messagesUnsub) messagesUnsub();
    messagesUnsub = onValue(msgsRef, snap => {
      $('#chatLog').innerHTML = '';
      const msgs = snap.val() || {};
      Object.entries(msgs).forEach(([, m]) => {
        const who = m.from === currentUser.uid ? 'me' : 'them';
        if (m.type === 'text') pushBubble(who, m.text, 'text');
        if (m.type === 'image') pushBubble(who, m.url, 'image');
        if (m.type === 'audio') pushBubble(who, m.url, 'audio');
      });
      $('#chatLog').scrollTop = $('#chatLog').scrollHeight;
    });
  }

  $('#chatSendBtn').addEventListener('click', async () => {
    const roomId = activeRoom;
    if (!roomId) return;
    const input = $('#chatInput');
    const text = input.value.trim();
    if (!text) return;
    input.value = '';
    const msgRef = push(rRef(db, `rooms/${roomId}/messages`));
    await set(msgRef, { from: currentUser.uid, type: 'text', text, ts: serverTimestamp() });
  });

  $('#chatPhotoBtn').addEventListener('click', () => $('#chatPhoto').click());
  $('#chatPhoto').addEventListener('change', async () => {
    const roomId = activeRoom;
    if (!roomId) return;
    const f = $('#chatPhoto').files?.[0];
    if (!f) return;
    const ext = (f.type && f.type.split('/')[1]) || 'jpg';
    const ref = sRef(storage, `chats/${roomId}/images/${Date.now()}.${ext}`);
    await uploadBytes(ref, f, { contentType: f.type || 'image/jpeg' });
    const url = await getDownloadURL(ref);
    const msgRef = push(rRef(db, `rooms/${roomId}/messages`));
    await set(msgRef, { from: currentUser.uid, type: 'image', url, ts: serverTimestamp() });
  });

  let chatRec = null, chatChunks = [], chatStream = null, chatMime = '';
  $('#chatVoiceBtn').addEventListener('click', async e => {
    const btn = e.currentTarget;
    const roomId = activeRoom;
    if (!roomId) return;
    if (!chatRec) {
      try {
        chatMime = supportedMime();
        chatStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        chatRec = new MediaRecorder(chatStream, chatMime ? { mimeType: chatMime } : undefined);
        chatChunks = [];
        chatRec.ondataavailable = ev => { if (ev.data?.size) chatChunks.push(ev.data); };
        chatRec.onstop = async () => {
          const blob = new Blob(chatChunks, { type: chatMime || 'audio/webm' });
          const ref = sRef(storage, `chats/${roomId}/voice/${Date.now()}.webm`);
          await uploadBytes(ref, blob, { contentType: blob.type || 'audio/webm' });
          const url = await getDownloadURL(ref);
          const msgRef = push(rRef(db, `rooms/${roomId}/messages`));
          await set(msgRef, { from: currentUser.uid, type: 'audio', url, ts: serverTimestamp() });
        };
        chatRec.start();
        btn.textContent = '‚èπÔ∏è';
      } catch (err) { alert('Mic access needed.'); console.error(err); chatRec = null; chatStream?.getTracks().forEach(t => t.stop()); }
    } else {
      chatRec.stop();
      chatStream?.getTracks().forEach(t => t.stop());
      chatRec = null;
      btn.textContent = 'üéôÔ∏è';
    }
  });

  $('#callBtn').addEventListener('click', async () => {
    const roomId = activeRoom;
    if (!roomId) return;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      peerConnection = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
      stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      await set(rRef(db, `calls/${roomId}/${currentUser.uid}`), {
        offer: { type: offer.type, sdp: offer.sdp },
        ts: serverTimestamp()
      });

      onValue(rRef(db, `calls/${roomId}`), snap => {
        const data = snap.val();
        if (!data) return;
        Object.entries(data).forEach(async ([uid, call]) => {
          if (uid === currentUser.uid) return;
          if (call.offer && !peerConnection.remoteDescription) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(call.offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            await set(rRef(db, `calls/${roomId}/${currentUser.uid}/answer`), {
              type: answer.type, sdp: answer.sdp
            });
          }
          if (call.answer && peerConnection.remoteDescription?.type === 'offer') {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(call.answer));
          }
        });
      });

      peerConnection.ontrack = e => {
        const audio = document.createElement('audio');
        audio.srcObject = e.streams[0];
        audio.autoplay = true;
        document.body.appendChild(audio);
      };

      peerConnection.onicecandidate = e => {
        if (e.candidate) {
          push(rRef(db, `calls/${roomId}/${currentUser.uid}/candidates`), e.candidate.toJSON());
        }
      };

      onValue(rRef(db, `calls/${roomId}/${currentUser.uid}/candidates`), snap => {
        const candidates = snap.val();
        if (candidates) {
          Object.values(candidates).forEach(candidate => peerConnection.addIceCandidate(new RTCIceCandidate(candidate)));
        }
      });
    } catch (err) { console.error('Voice call failed', err); alert('Voice call setup failed.'); }
  });

  /***** START APP *****/
  go(0);
</script>
</body>
</html>