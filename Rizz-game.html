<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Le Libido — Audio Pickup Editor</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700;800&display=swap" rel="stylesheet">
<style>
  :root{ --gold:#e1bf78; --blue:#064D95; --green:#06954E; --red:#950606; --bg:#0d0d0d; --card:#151515; --muted:#b9b9b9; }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:var(--bg);font-family:Montserrat,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:#fff}
  .border-wrap{min-height:100vh;padding:2px;background:linear-gradient(100deg,var(--red),var(--blue),var(--green))}
  .app{min-height:calc(100vh - 4px);background:var(--bg);display:flex;flex-direction:column;align-items:center}
  header{width:100%;padding:22px 16px 8px;text-align:center}
  header img{width:120px;height:auto;display:block;margin:0 auto 10px;filter:drop-shadow(0 0 10px rgba(225,191,120,.25))}
  .title{font-weight:800;letter-spacing:.5px;font-size:clamp(20px,3vw,28px);text-shadow:0 0 8px rgba(225,191,120,.25)}
  .steps{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;padding:6px 16px 14px;width:100%}
  .step-pill{padding:8px 12px;border:1px solid rgba(225,191,120,.3);border-radius:999px;color:#fff;font-weight:600;font-size:12px;opacity:.6;user-select:none}
  .step-pill.active{opacity:1;border-color:var(--gold);box-shadow:0 0 14px rgba(225,191,120,.2) inset}
  .panel{width:min(1100px,94vw);background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:18px;margin:10px auto 28px;box-shadow:0 25px 60px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.02)}
  .panel h2{margin:6px 8px 14px;font-size:18px;font-weight:800;letter-spacing:.3px}
  .grid{display:grid;gap:14px} .grid.cols-2{grid-template-columns:1fr 1fr} @media (max-width:800px){.grid.cols-2{grid-template-columns:1fr}}
  .btn{appearance:none;border:0;border-radius:12px;padding:14px 18px;background:linear-gradient(180deg,#1e1e1e,#121212);color:#fff;font-weight:700;letter-spacing:.3px;cursor:pointer;border:1px solid rgba(255,255,255,.08);transition:.2s transform,.2s box-shadow,.2s background}
  .btn:hover{transform:translateY(-1px);box-shadow:0 8px 24px rgba(0,0,0,.35)}
  .btn.gold{background:linear-gradient(180deg,#f4d796,#c9a760);color:#111;border:1px solid #d7b56f;text-shadow:0 1px 0 rgba(255,255,255,.35)}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,.18)}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center} .hidden{display:none !important}
  label{font-size:12px;color:#e5e5e5;margin-bottom:6px;display:block}
  input[type="text"],select{width:100%;padding:12px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:#111;color:#fff;outline:none;font-size:14px;touch-action:manipulation}
  .rec-wrap{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.01));border:1px dashed rgba(255,255,255,.15);border-radius:14px;padding:16px}
  .record-btn{width:160px;height:160px;border-radius:999px;border:1px solid rgba(255,255,255,.15);cursor:pointer;background:radial-gradient(closest-side, rgba(225,191,120,.25) 0%, rgba(225,191,120,0) 78%),linear-gradient(180deg,#272727,#161616);color:#fff;font-weight:800;font-size:15px;letter-spacing:.5px;box-shadow:0 20px 60px rgba(0,0,0,.45),0 0 0 6px rgba(225,191,120,.08) inset}
  .rec-indicator{width:10px;height:10px;background:#f34a4a;border-radius:50%;box-shadow:0 0 12px rgba(243,74,74,.9);display:inline-block;margin-right:8px;vertical-align:middle;animation:pulse 1s infinite}
  @keyframes pulse{0%{transform:scale(1);opacity:1}50%{transform:scale(1.3);opacity:.65}100%{transform:scale(1);opacity:1}}
  .player{display:flex;align-items:center;gap:12px;margin-top:14px}
  .play-toggle{width:46px;height:46px;border-radius:50%;border:1px solid rgba(255,255,255,.15);background:#151515;color:#fff;font-weight:800;cursor:pointer}
  .bar{flex:1;height:10px;background:#0f0f0f;border-radius:999px;position:relative;border:1px solid rgba(255,255,255,.1);overflow:hidden;cursor:pointer}
  .bar .fill{position:absolute;inset:0 100% 0 0;background:linear-gradient(90deg,var(--red),var(--blue),var(--green));border-right:2px solid rgba(255,255,255,.5)}
  .time{font-size:12px;color:var(--muted);width:74px;text-align:right}
  .editor-wrap{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.01));border:1px dashed rgba(255,255,255,.15);border-radius:14px;padding:锻16px;margin-top:16px}
  .timeline{height:60px;background:#0f0f0f;border:1px solid rgba(255,255,255,.1);border-radius:8px;position:relative;overflow:hidden}
  .segment{position:absolute;height:100%;background:rgba(225,191,120,.2);cursor:move}
  .effects{display:flex;gap:8px;margin-top:10px}
  .effect-btn{padding:6px 10px;border-radius:999px;background:#151515;border:1px solid rgba(255,255,255,.15);cursor:pointer;font-size:12px;color:#fff}
  .deck{position:relative;height:420px;border-radius:16px;overflow:hidden;background:#0f0f10;border:1px solid rgba(255,255,255,.08)}
  .card{position:absolute;inset:0;padding:18px;display:flex;flex Nurses:direction:column;justify-content:flex-end;background:radial-gradient(1200px 500px at 100% -10%, rgba(255,255,255,.06), transparent 70%),linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01))}
  .swipe-actions{display:flex;gap:10px}
  .pass,.like{flex:1;padding:12px 14px;border-radius:10px;font-weight:800;border:1px solid rgba(255,255,255,.12);cursor:pointer}
  .pass{background:#151515;color:#ddd}
  .like{background:linear-gradient(180deg,#f4d796,#bf9a55);color:#111}
  .match-modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6);z-index:50}
  .match-box{width:min(520px,92vw);background:#121212;border:1px solid rgba(255,255,255,.12);border-radius:16px;padding:18px;text-align:center}
  .chat{height:420px;display:flex;flex-direction:column;border-radius:12px;overflow:hidden;border:1px solid rgba(255,255,255,.1);background:#0f0f10}
  .chat-log{flex:1;overflow:auto;padding:14px;display:flex;flex-direction:column;gap:10px}
  .bubble{max-width:78%;padding:10px 12px;border-radius:12px;font-size:14px;line-height:1.35}
  .me{align-self:flex-end;background:#172015;border:1px solid rgba(225,191,120,.25)}
  .them{align-self:flex-start;background:#141414;border:1px solid rgba(255,255,255,.12)}
  .composer{display:flex;gap:8px;padding:10px;border-top:1px solid rgba(255,255,255,.08);background:#101010}
  .composer input[type="text"]{flex:1;background:#0f0f0f;border:1px solid rgba(255,255,255,.12)}
  .small{font-size:12px;color:var(--muted)} .tip{color:var(--muted);font-size:12px;margin-top:6px}
</style>
</head>
<body>
<div class="border-wrap">
  <div class="app">
    <header>
      <img src="golden-le-libido-logo.png" alt="Le Libido" onerror="this.style.opacity=.0">
      <div class="title">Blind Audio Pickup</div>
      <div class="small">Craft your pickup line with effects. Match to unlock chats.</div>
    </header>

    <div class="steps" id="stepper">
      <div class="step-pill active">1 • Record & Edit</div>
      <div class="step-pill">2 • Swipe</div>
      <div class="step-pill">3 • Chat</div>
    </div>

    <!-- STEP 1: Record & Edit -->
    <section class="panel" id="step1">
      <h2>Step 1 — Craft your pickup line</h2>
      <div class="grid cols-2">
        <div class="rec-wrap">
          <div class="row" style="align-items:center; justify-content:center; gap:18px; margin-bottom:12px">
            <button class="record-btn" id="recordBtn"><span id="recLabel">Start Recording</span></button>
            <div>
              <div class="small">Tap to record, edit with effects, keep under 15s.</div>
              <div class="tip">Use HTTPS and allow mic permission.</div>
            </div>
          </div>
          <div id="playerBlock" class="hidden">
            <div class="player">
              <button class="play-toggle" id="playToggle">▶</button>
              <div class="bar" id="seekBar"><div class="fill" id="fill"></div></div>
              <div class="time" id="time">0:00</div>
            </div>
            <div class="row" style="margin-top:10px">
              <button class="btn ghost" id="retakeBtn">Retake</button>
            </div>
            <audio id="audio" preload="metadata" class="hidden"></audio>
          </div>
          <div id="editorBlock" class="editor-wrap hidden">
            <h3>Edit Your Pickup</h3>
            <div class="timeline" id="timeline"></div>
            <div class="effects">
              <button class="effect-btn" data-effect="echo">Echo</button>
              <button class="effect-btn" data-effect="pitchUp">Pitch Up</button>
              <button class="effect-btn" data-effect="addSound" data-sound="laugh">Add Laugh</button>
              <button class="effect-btn" data-effect="addSound" data-sound="clap">Add Clap</button>
            </div>
            <div class="row" style="margin-top:10px">
              <button class="btn gold" id="saveEditBtn">Save & Swipe →</button>
            </div>
          </div>
        </div>
        <div class="rec-wrap">
          <strong>Great pickup lines are:</strong>
          <ul style="margin-top:8px; color:#ddd; line-height:1.5">
            <li>Short, playful, creative with effects</li>
            <li>Flirty and fun, not cheesy</li>
            <li>Unique with sounds or vibe</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- STEP 2: Swipe -->
    <section class="panel hidden" id="step2">
      <h2>Step 2 — Swipe pickup lines</h2>
      <div class="deck" id="deck"></div>
      <div class="tip">Hear creative lines. Like to match and unlock chats.</div>
    </section>

    <!-- STEP 3: Chat -->
    <section class="panel hidden" id="step3">
      <h2>Private Chat</h2>
      <div class="chat" id="chat">
        <div class="chat-log" id="chatLog"></div>
        <div class="composer">
          <input type="text" id="chatInput" placeholder="Type a message…" />
          <input type="file" id="chatPhoto" accept="image/*" class="hidden">
          <button class="btn" id="chatPhotoBtn">📷</button>
          <button class="btn" id="chatVoiceBtn">🎙️</button>
          <button class="btn" id="callBtn">📞</button>
          <button class="btn gold" id="chatSendBtn">Send</button>
        </div>
        <div class="tip">Send texts, pics, voice memos, or start a voice call.</div>
      </div>
    </section>

    <!-- MATCH MODAL -->
    <div class="match-modal" id="matchModal" role="dialog" aria-modal="true">
      <div class="match-box">
        <h3>It’s a Match!</h3>
        <p>You both liked each other’s pickup line. Chat unlocked!</p>
        <div class="row" style="justify-content:center">
          <button class="btn ghost" id="closeMatch">Keep Swiping</button>
          <button class="btn gold" id="openChat">Open Chat</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Firebase + App logic -->
<script type="module">
  /***** FIREBASE IMPORTS *****/
  import { app, db } from './firebase-config.js';
  import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js';
  import { getStorage, ref as sRef, uploadBytes, getDownloadURL } from 'https://www.gstatic.com/firebasejs/10.12.3/firebase-storage.js';
  import { ref as rRef, set, get, onValue, push, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js';

  const auth = getAuth(app);
  const storage = getStorage(app);

  let currentUser = null;
  try { await signInAnonymously(auth); } catch (e) { console.error('Anon sign-in failed', e); }
  onAuthStateChanged(auth, u => { currentUser = u || null; });

  /***** BASIC NAV / STEP UI *****/
  const $ = s => document.querySelector(s);
  const stepper = $('#stepper').children;
  function go(i) {
    ['#step1', '#step2', '#step3'].forEach((id, idx) => {
      const el = $(id);
      if (idx === i) { el.classList.remove('hidden'); stepper[idx].classList.add('active'); }
      else { el.classList.add('hidden'); stepper[idx].classList.remove('active'); }
    });
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }
  Array.from(stepper).forEach((pill, idx) => {
    pill.style.cursor = 'pointer';
    pill.addEventListener('click', () => {
      if (idx === 1 && !window.__recBlob) { alert('Record and edit your pickup line first.'); return; }
      if (idx === 2 && !window.__activeRoom) { alert('Open a match from the deck to chat.'); return; }
      go(idx);
      if (idx === 1 && !window.__deckInit) initDeck();
    });
  });

  /***** RECORDING *****/
  const recordBtn = $('#recordBtn'), recLabel = $('#recLabel');
  const audioEl = $('#audio'), playerBlock = $('#playerBlock');
  const playToggle = $('#playToggle'), seekBar = $('#seekBar'), fill = $('#fill'), time = $('#time');
  const retakeBtn = $('#retakeBtn'), saveEditBtn = $('#saveEditBtn');
  let mediaRecorder, recChunks = [], recStream = null, recMime = '', recording = false;
  window.__recBlob = null; // pickup line blob

  function supportedMime() {
    const c = ['audio/webm;codecs=opus', 'audio/mp4;codecs=aac', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/mp4', 'audio/aac'];
    for (const t of c) { if (window.MediaRecorder?.isTypeSupported?.(t)) return t; }
    return '';
  }
  async function startRecording() {
    try {
      recMime = supportedMime();
      recStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(recStream, recMime ? { mimeType: recMime } : undefined);
      recChunks = [];
      mediaRecorder.ondataavailable = e => { if (e.data?.size) recChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        window.__recBlob = new Blob(recChunks, { type: recMime || 'audio/webm' });
        const url = URL.createObjectURL(window.__recBlob);
        audioEl.src = url;
        playerBlock.classList.remove('hidden');
        document.getElementById('editorBlock').classList.remove('hidden');
        initEditor(url);
      };
      mediaRecorder.start();
      recording = true;
      recLabel.innerHTML = '<span class="rec-indicator"></span> Recording…';
    } catch (err) { alert('Mic permission needed. Use HTTPS.'); console.error(err); }
  }
  function stopRecording() {
    if (mediaRecorder && recording) {
      mediaRecorder.stop();
      recStream?.getTracks().forEach(t => t.stop());
      recording = false;
      recLabel.textContent = 'Start Recording';
    }
  }
  recordBtn.addEventListener('click', () => recording ? stopRecording() : startRecording());

  const fmt = s => { s = Math.floor(s); const m = Math.floor(s / 60), r = s % 60; return `${m}:${r.toString().padStart(2, '0')}`; };
  function updateTime(c, d) { time.textContent = `${fmt(c)} / ${d ? fmt(d) : '0:00'}`; }
  playToggle.addEventListener('click', () => {
    if (audioEl.paused) { audioEl.play(); playToggle.textContent = '⏸'; } else { audioEl.pause(); playToggle.textContent = '▶'; }
  });
  audioEl.addEventListener('pause', () => playToggle.textContent = '▶');
  audioEl.addEventListener('play', () => playToggle.textContent = '⏸');
  audioEl.addEventListener('timeupdate', () => {
    const d = audioEl.duration || 0, c = audioEl.currentTime || 0, pct = d ? (c / d) * 100 : 0;
    fill.style.inset = `0 ${100 - pct}% 0 0`;
    updateTime(c, d);
  });
  seekBar.addEventListener('click', (e) => {
    const r = seekBar.getBoundingClientRect();
    const x = (e.clientX - r.left) / r.width;
    if (audioEl.duration) audioEl.currentTime = x * audioEl.duration;
  });
  retakeBtn.addEventListener('click', () => {
    if (!audioEl.paused) audioEl.pause();
    playerBlock.classList.add('hidden');
    document.getElementById('editorBlock').classList.add('hidden');
    window.__recBlob = null;
    audioEl.removeAttribute('src');
  });

  /***** AUDIO EDITOR *****/
  let audioCtx, sourceNode, editedBuffer;
  async function initEditor(url) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const resp = await fetch(url);
    const arrayBuf = await resp.arrayBuffer();
    editedBuffer = await audioCtx.decodeAudioData(arrayBuf);
    renderTimeline();
  }

  function renderTimeline() {
    const tl = document.getElementById('timeline');
    tl.innerHTML = '';
    const seg = document.createElement('div');
    seg.className = 'segment';
    seg.style.width = '100%';
    tl.appendChild(seg);
    // Basic drag support
    let isDragging = false;
    seg.addEventListener('mousedown', () => isDragging = true);
    window.addEventListener('mousemove', (e) => {
      if (isDragging) {
        // Update segment position (simplified)
      }
    });
    window.addEventListener('mouseup', () => isDragging = false);
  }

  document.querySelectorAll('.effect-btn').forEach(btn => {
    btn.addEventListener('click', applyEffect);
  });

  async function applyEffect(e) {
    const effect = e.target.dataset.effect;
    if (effect === 'echo') {
      const convolver = audioCtx.createConvolver();
      const impulse = audioCtx.createBuffer(2, audioCtx.sampleRate * 0.5, audioCtx.sampleRate);
      for (let i = 0; i < impulse.length; i++) {
        impulse.getChannelData(0)[i] = (Math.random() * 2 - 1) * (1 - i / impulse.length) * 0.2;
        impulse.getChannelData(1)[i] = (Math.random() * 2 - 1) * (1 - i / impulse.length) * 0.2;
      }
      convolver.buffer = impulse;
      sourceNode = audioCtx.createBufferSource();
      sourceNode.buffer = editedBuffer;
      sourceNode.connect(convolver).connect(audioCtx.destination);
      sourceNode.start();
    } else if (effect === 'pitchUp') {
      sourceNode = audioCtx.createBufferSource();
      sourceNode.buffer = editedBuffer;
      sourceNode.playbackRate.value = 1.2;
      sourceNode.connect(audioCtx.destination);
      sourceNode.start();
    } else if (effect === 'addSound') {
      const sound = e.target.dataset.sound;
      // Assume sound files in Firebase Storage: e.g., /sounds/laugh.mp3
      const soundUrl = await getDownloadURL(sRef(storage, `sounds/${sound}.mp3`));
      const resp = await fetch(soundUrl);
      const soundBuf = await audioCtx.decodeAudioData(await resp.arrayBuffer());
      // Mix: create new buffer
      const maxLen = Math.max(editedBuffer.length, soundBuf.length);
      const newBuffer = audioCtx.createBuffer(2, maxLen, audioCtx.sampleRate);
      for (let ch = 0; ch < 2; ch++) {
        const data = newBuffer.getChannelData(ch);
        const orig = editedBuffer.getChannelData(ch);
        const snd = soundBuf.getChannelData(ch);
        for (let i = 0; i < maxLen; i++) {
          data[i] = (orig[i] || 0) + (snd[i] || 0) * 0.5; // Simple mix
        }
      }
      editedBuffer = newBuffer;
      sourceNode = audioCtx.createBufferSource();
      sourceNode.buffer = editedBuffer;
      sourceNode.connect(audioCtx.destination);
      sourceNode.start();
    }
    // Update preview
    const tempBlob = await audioBufferToBlob(editedBuffer);
    audioEl.src = URL.createObjectURL(tempBlob);
  }

  async function audioBufferToBlob(buffer) {
    const offlineCtx = new OfflineAudioContext(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
    const src = offlineCtx.createBufferSource();
    src.buffer = buffer;
    src.connect(offlineCtx.destination);
    src.start();
    const rendered = await offlineCtx.startRendering();
    const wav = await audioBufferToWav(rendered);
    return new Blob([wav], { type: 'audio/wav' });
  }

  async function audioBufferToWav(buffer) {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const length = buffer.length * numChannels * 2 + 44;
    const arrayBuffer = new ArrayBuffer(length);
    const view = new DataView(arrayBuffer);

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    let offset = 0;
    writeString(view, offset, 'RIFF'); offset += 4;
    view.setUint32(offset, 36 + buffer.length * numChannels * 2, true); offset += 4;
    writeString(view, offset, 'WAVE'); offset += 4;
    writeString(view, offset, 'fmt '); offset += 4;
    view.setUint32(offset, 16, true); offset += 4;
    view.setUint16(offset, 1, true); offset += 2;
    view.setUint16(offset, numChannels, true); offset += 2;
    view.setUint32(offset, sampleRate, true); offset += 4;
    view.setUint32(offset, sampleRate * numChannels * 2, true); offset += 4;
    view.setUint16(offset, numChannels * 2, true); offset += 2;
    view.setUint16(offset, 16, true); offset += 2;
    writeString(view, offset, 'data'); offset += 4;
    view.setUint32(offset, buffer.length * numChannels * 2, true); offset += 4;

    for (let i = 0; i < buffer.length; i++) {
      for (let ch = 0; ch < numChannels; ch++) {
        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(ch)[i]));
        view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
        offset += 2;
      }
    }
    return arrayBuffer;
  }

  saveEditBtn.addEventListener('click', async () => {
    if (!window.__recBlob) { alert('Record and edit your pickup line first.'); return; }
    const lineRef = sRef(storage, `lines/${currentUser.uid}/${Date.now()}.wav`);
    await uploadBytes(lineRef, window.__recBlob, { contentType: 'audio/wav' });
    const lineURL = await getDownloadURL(lineRef);
    await set(rRef(db, `lines/${currentUser.uid}`), { uid: currentUser.uid, lineURL, ts: serverTimestamp() });
    go(1);
    initDeck();
  });

  /***** SWIPE: AUDIO LINES *****/
  const deckEl = $('#deck');
  let deck = [], deckIdx = 0;
  window.__deckInit = false;

  function listenLines() {
    const pRef = rRef(db, 'lines');
    onValue(pRef, snap => {
      const all = snap.val() || {};
      deck = Object.values(all).filter(p => p.uid !== currentUser?.uid && p.lineURL);
      deckIdx = 0;
      renderCard();
    });
  }

  function initDeck() {
    if (window.__deckInit) return;
    window.__deckInit = true;
    listenLines();
  }

  async function renderCard() {
    deckEl.innerHTML = '';
    if (!deck.length || deckIdx >= deck.length) {
      const empty = document.createElement('div');
      empty.className = 'card';
      empty.innerHTML = `<h3>${deck.length ? 'That’s all for now' : 'No lines yet'}</h3>
        <div class="small">${deck.length ? 'New pickup lines appear as more people join.' : 'Be the first—share your link!'}</div>`;
      deckEl.appendChild(empty);
      return;
    }
    const p = deck[deckIdx];
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `
      <div class="small">🎧 Listen to their creative pickup line.</div>
      <div class="rec-wrap">
        <div class="player">
          <button class="play-toggle">▶</button>
          <div class="bar"><div class="fill"></div></div>
          <div class="time">0:00</div>
        </div>
        <audio preload="metadata" class="hidden"></audio>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="pass">Pass</button>
        <button class="like">Like</button>
      </div>`;
    deckEl.appendChild(card);

    const audio = card.querySelector('audio');
    audio.src = p.lineURL;
    const playBtn = card.querySelector('.play-toggle');
    const bar = card.querySelector('.bar');
    const fill = card.querySelector('.fill');
    const tm = card.querySelector('.time');
    const fmt = s => { s = Math.floor(s); const m = Math.floor(s / 60), r = s % 60; return `${m}:${r.toString().padStart(2, '0')}`; };
    playBtn.addEventListener('click', () => {
      if (audio.paused) { audio.play(); playBtn.textContent = '⏸'; } else { audio.pause(); playBtn.textContent = '▶'; }
    });
    audio.addEventListener('pause', () => playBtn.textContent = '▶');
    audio.addEventListener('play', () => playBtn.textContent = '⏸');
    audio.addEventListener('timeupdate', () => {
      const d = audio.duration || 0, c = audio.currentTime || 0, pct = d ? (c / d) * 100 : 0;
      fill.style.inset = `0 ${100 - pct}% 0 0`;
      tm.textContent = `${fmt(c)} / ${d ? fmt(d) : '0:00'}`;
    });
    bar.addEventListener('click', (e) => {
      const r = bar.getBoundingClientRect();
      const x = (e.clientX - r.left) / r.width;
      if (audio.duration) audio.currentTime = x * audio.duration;
    });

    card.querySelector('.pass').addEventListener('click', () => { audio.pause(); deckIdx++; renderCard(); });
    card.querySelector('.like').addEventListener('click', () => { audio.pause(); handleLike(p.uid); });
  }

  /***** MATCHING *****/
  function pairIdFor(a, b) { return [a, b].sort().join('_'); }

  async function handleLike(themUid) {
    const me = currentUser.uid;
    const myLikeRef = rRef(db, `likes/${me}/${themUid}`);
    const theirLikeRef = rRef(db, `likes/${themUid}/${me}`);

    await set(myLikeRef, true);
    const theirLikeSnap = await get(theirLikeRef);
    const matched = !!theirLikeSnap.val();

    if (!matched) { deckIdx++; renderCard(); return; }

    const pid = pairIdFor(me, themUid);
    const pairRef = rRef(db, `pairs/${pid}`);
    const pairSnap = await get(pairRef);

    if (!pairSnap.exists()) {
      await set(pairRef, { id: pid, a: me, b: themUid, roomId: pid, ts: serverTimestamp() });
      await set(rRef(db, `rooms/${pid}`), { id: pid, a: me, b: themUid, created: serverTimestamp() });
    }

    showMatch(pid);
  }

  function showMatch(roomId) {
    const m = $('#matchModal');
    m.style.display = 'flex';
    $('#closeMatch').onclick = () => { m.style.display = 'none'; deckIdx++; renderCard(); };
    $('#openChat').onclick = () => { m.style.display = 'none'; openChat(roomId); };
  }

  /***** CHAT (Realtime DB + Storage + WebRTC) *****/
  let activeRoom = null;
  window.__activeRoom = null;
  let messagesUnsub = null;
  let peerConnection = null;

  function pushBubble(who, content, type = 'text') {
    const log = $('#chatLog');
    const b = document.createElement('div');
    b.className = `bubble ${who}`;
    if (type === 'text') { b.textContent = content; }
    if (type === 'image') { const img = document.createElement('img'); img.src = content; b.appendChild(img); }
    if (type === 'audio') { const a = document.createElement('audio'); a.controls = true; a.src = content; b.appendChild(a); }
    log.appendChild(b);
    log.scrollTop = log.scrollHeight;
  }

  function openChat(roomId) {
    activeRoom = roomId;
    window.__activeRoom = roomId;
    $('#chatLog').innerHTML = '';
    go(2);

    const msgsRef = rRef(db, `rooms/${roomId}/messages`);
    if (messagesUnsub) messagesUnsub();
    messagesUnsub = onValue(msgsRef, snap => {
      $('#chatLog').innerHTML = '';
      const msgs = snap.val() || {};
      Object.entries(msgs).forEach(([, m]) => {
        const who = m.from === currentUser.uid ? 'me' : 'them';
        if (m.type === 'text') pushBubble(who, m.text, 'text');
        if (m.type === 'image') pushBubble(who, m.url, 'image');
        if (m.type === 'audio') pushBubble(who, m.url, 'audio');
      });
      $('#chatLog').scrollTop = $('#chatLog').scrollHeight;
    });
  }

  $('#chatSendBtn').addEventListener('click', async () => {
    const roomId = activeRoom;
    if (!roomId) return;
    const input = $('#chatInput');
    const text = input.value.trim();
    if (!text) return;
    input.value = '';
    const msgRef = push(rRef(db, `rooms/${roomId}/messages`));
    await set(msgRef, { from: currentUser.uid, type: 'text', text, ts: serverTimestamp() });
  });

  $('#chatPhotoBtn').addEventListener('click', () => $('#chatPhoto').click());
  $('#chatPhoto').addEventListener('change', async () => {
    const roomId = activeRoom;
    if (!roomId) return;
    const f = $('#chatPhoto').files?.[0];
    if (!f) return;
    const ext = (f.type && f.type.split('/')[1]) || 'jpg';
    const ref = sRef(storage, `chats/${roomId}/images/${Date.now()}.${ext}`);
    await uploadBytes(ref, f, { contentType: f.type || 'image/jpeg' });
    const url = await getDownloadURL(ref);
    const msgRef = push(rRef(db, `rooms/${roomId}/messages`));
    await set(msgRef, { from: currentUser.uid, type: 'image', url, ts: serverTimestamp() });
  });

  let chatRec = null, chatChunks = [], chatStream = null, chatMime = '';
  $('#chatVoiceBtn').addEventListener('click', async (e) => {
    const btn = e.currentTarget;
    const roomId = activeRoom;
    if (!roomId) return;
    if (!chatRec) {
      try {
        chatMime = supportedMime();
        chatStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        chatRec = new MediaRecorder(chatStream, chatMime ? { mimeType: chatMime } : undefined);
        chatChunks = [];
        chatRec.ondataavailable = ev => { if (ev.data?.size) chatChunks.push(ev.data); };
        chatRec.onstop = async () => {
          const blob = new Blob(chatChunks, { type: chatMime || 'audio/webm' });
          const ref = sRef(storage, `chats/${roomId}/voice/${Date.now()}.webm`);
          await uploadBytes(ref, blob, { contentType: blob.type || 'audio/webm' });
          const url = await getDownloadURL(ref);
          const msgRef = push(rRef(db, `rooms/${roomId}/messages`));
          await set(msgRef, { from: currentUser.uid, type: 'audio', url, ts: serverTimestamp() });
        };
        chatRec.start();
        btn.textContent = '⏹️';
      } catch (err) { alert('Mic access needed.'); console.error(err); chatRec = null; chatStream?.getTracks().forEach(t => t.stop()); }
    } else {
      chatRec.stop();
      chatStream?.getTracks().forEach(t => t.stop());
      chatRec = null;
      btn.textContent = '🎙️';
    }
  });

  // WebRTC Voice Call
  $('#callBtn').addEventListener('click', async () => {
    const roomId = activeRoom;
    if (!roomId) return;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      peerConnection = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
      stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      await set(rRef(db, `calls/${roomId}/${currentUser.uid}`), {
        offer: { type: offer.type, sdp: offer.sdp },
        ts: serverTimestamp()
      });

      onValue(rRef(db, `calls/${roomId}`), snap => {
        const data = snap.val();
        if (!data) return;
        Object.entries(data).forEach(async ([uid, call]) => {
          if (uid === currentUser.uid) return;
          if (call.offer && !peerConnection.remoteDescription) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(call.offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            await set(rRef(db, `calls/${roomId}/${currentUser.uid}/answer`), {
              type: answer.type, sdp: answer.sdp
            });
          }
          if (call.answer && peerConnection.remoteDescription?.type === 'offer') {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(call.answer));
          }
        });
      });

      peerConnection.ontrack = e => {
        const audio = document.createElement('audio');
        audio.srcObject = e.streams[0];
        audio.autoplay = true;
        document.body.appendChild(audio);
      };

      peerConnection.onicecandidate = e => {
        if (e.candidate) {
          push(rRef(db, `calls/${roomId}/${currentUser.uid}/candidates`), e.candidate);
        }
      };

      onValue(rRef(db, `calls/${roomId}/${currentUser.uid}/candidates`), snap => {
        const candidates = snap.val();
        if (candidates) {
          Object.values(candidates).forEach(candidate => peerConnection.addIceCandidate(new RTCIceCandidate(candidate)));
        }
      });
    } catch (err) { console.error('Voice call failed', err); alert('Voice call setup failed.'); }
  });

  /***** START APP *****/
  go(0);
</script>
</body>
</html>