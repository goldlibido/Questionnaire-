<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Rizzler: Drop Your Best Line</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{--gold:#e1bf78;--blue:#064D95;--green:#06954E;--red:#c40018;--redBright:#ff1e2d;}
  body{font-family:'Montserrat',sans-serif;background:#000;color:#fff;text-align:center;padding:20px;margin:0;overflow:hidden}
  .container{max-width:640px;margin:0 auto;border:2px solid var(--gold);border-radius:15px;padding:20px;box-shadow:0 0 20px var(--gold)}
  h1{font-size:2em;color:var(--gold);margin-bottom:10px}
  h1 .pulse{color:var(--redBright);display:inline-block;animation:pulse 1.4s ease-in-out infinite}
  @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.15)}100%{transform:scale(1)}}
  button{padding:14px 26px;margin:8px;font-size:1.05em;border:none;border-radius:24px;cursor:pointer;transition:transform .2s,box-shadow .2s;color:#fff}
  button:hover{transform:scale(1.06);box-shadow:0 0 10px currentColor}
  #enter-btn{background:var(--red)} #connect-btn{background:#444}
  #speak-btn{background:var(--green)} #listen-btn{background:var(--blue)}
  #accept-btn{background:var(--red)}
  #send-btn,#audio-send-btn{background:var(--green)} #photo-btn{background:var(--blue)}
  input[type="text"]{padding:10px;margin:5px;border:1px solid var(--gold);border-radius:10px;background:#222;color:#fff}
  .row{display:flex;gap:8px;justify-content:center;align-items:center;flex-wrap:wrap}
  .hidden{display:none}
  #me-line{opacity:.9;margin:10px 0 6px}
  #status{opacity:.9;min-height:1.2em}
  #audio-player{margin:16px auto;width:100%}
  #chat-window{height:260px;overflow-y:auto;border:1px solid var(--gold);border-radius:10px;padding:10px;background:#111;margin-bottom:10px;text-align:left}
  .chat-message{padding:8px 10px;margin:6px 0;border-radius:12px;max-width:85%;word-wrap:break-word;animation:slideIn .3s ease-out;display:inline-block}
  .sent{background:var(--green);margin-left:auto}
  .received{background:var(--blue);margin-right:auto}
  @keyframes slideIn{from{transform:translateY(14px);opacity:0}to{transform:translateY(0);opacity:1}}
  body::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle,rgba(225,191,120,.1) 0%,rgba(0,0,0,0) 100%);z-index:-1}
</style>
</head>
<body>
<div class="container">
  <h1>Rizzler: Unleash Your <span class="pulse">Rizz</span>!</h1>

  <!-- Profile -->
  <div id="profile-form">
    <input type="text" id="display-name" placeholder="Your display name (optional)">
    <button id="enter-btn">Enter the Game</button>
    <div id="me-line" class="hidden"></div>
    <div id="status"></div>
  </div>

  <!-- Main -->
  <div id="main" class="hidden">
    <div class="row" style="margin-top:6px">
      <input type="text" id="partner-id" placeholder="Partner ID (optional)" style="min-width:220px">
      <button id="connect-btn" title="Connect to partner by ID">Connect</button>
    </div>
    <button id="speak-btn">Speak & Rizz</button>
    <button id="listen-btn">Listen & Get Rizzed</button>
  </div>

  <!-- Speak -->
  <div id="speak-section" class="hidden">
    <p><strong>Record your line:</strong></p>
    <button id="record-toggle">Start Recording</button>
    <div style="opacity:.85;margin-top:6px">Tap once to start; tap again to stop & send.</div>
  </div>

  <!-- Listen -->
  <div id="listen-section" class="hidden">
    <audio id="audio-player" controls crossorigin="anonymous" playsinline></audio><br>
    <button id="accept-btn" class="hidden">Accept & Match</button>
    <div style="opacity:.85;margin-top:6px">Audio will play here when a line arrives.</div>
  </div>

  <!-- Match / Chat -->
  <div id="match-section" class="hidden">
    <h2>Chat</h2>
    <div id="chat-window"></div>
    <div class="row">
      <input type="text" id="chat-input" placeholder="Type your message‚Ä¶" style="flex:1;min-width:180px">
      <button id="send-btn">Send</button>
      <input id="photo-input" class="hidden" type="file" accept="image/*" capture="environment">
      <button id="photo-btn" title="Send photo">üì∑</button>
      <button id="audio-send-btn" title="Record/send audio">üéôÔ∏è</button>
    </div>
  </div>
</div>

<!-- PeerJS -->
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
/* ---------- State ---------- */
let peer, conn, myId = null;
let mediaRecorder = null, recordingStream = null, audioChunks = [];
let chatRecorder = null, chatStream = null, chatChunks = [];
let incomingChunks = [], incomingMime = 'audio/webm;codecs=opus';
let rxChat = { parts: [], mime: 'audio/webm;codecs=opus' };
let rxImage = { parts: [], mime: 'image/jpeg' };

const CHUNK_SIZE = 16 * 1024;

/* ---------- Helpers ---------- */
const $ = sel => document.querySelector(sel);
const setStatus = s => $('#status').textContent = s || '';
const show = el => el.classList.remove('hidden');
const hide = el => el.classList.add('hidden');

function getSupportedMime() {
  const types = ['audio/mp4', 'audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus'];
  for (const t of types) if (window.MediaRecorder?.isTypeSupported?.(t)) return t;
  return '';
}
function playBlobInAudio(blob) {
  const audio = $('#audio-player');
  const url = URL.createObjectURL(blob);
  audio.srcObject = null; audio.src = url; audio.load();
  audio.play().catch(()=>{});
}

/* ---------- PeerJS ---------- */
function initPeer() {
  peer = new Peer(undefined,{
    debug:2,
    config:{ iceServers:[
      {urls:'stun:stun.l.google.com:19302'},
      {urls:'stun:stun1.l.google.com:19302'},
      {urls:'stun:stun2.l.google.com:19302'}
    ]}
  });

  peer.on('open', id => {
    myId = id;
    show($('#me-line'));
    $('#me-line').textContent = `Your ID: ${id}`;
    setStatus('Share your ID with your partner, or paste theirs below.');
  });

  peer.on('connection', establish);

  // We only use the data channel (no media calls)
  peer.on('call', call => { try{ call.close(); }catch{} });

  peer.on('disconnected', ()=>{ try{peer.reconnect();}catch{} });
  peer.on('error', e => console.error('Peer error:', e));
}

function establish(connection) {
  // Prefer a single active connection
  if (conn && conn.open && connection.peer !== conn.peer) { try{connection.close();}catch{}; return; }

  conn = connection;
  conn.on('open', () => {
    hide($('#profile-form')); show($('#main'));
    setStatus('Connected! Choose Speak or Listen.');
  });
  conn.on('data', handleData);
  conn.on('close', onDisconnect);
  conn.on('error', onDisconnect);
}

function onDisconnect() {
  setStatus('Partner disconnected. You can connect to a new partner.');
  conn = null;
  hide($('#speak-section')); hide($('#listen-section')); hide($('#match-section'));
  show($('#main'));
}

/* ---------- Connect UI ---------- */
$('#enter-btn').addEventListener('click', () => {
  hide($('#profile-form')); show($('#main'));
  setStatus('Initializing‚Ä¶');
  initPeer();
});

$('#connect-btn').addEventListener('click', () => {
  const pid = ($('#partner-id').value || '').trim();
  if (!pid) { alert('Enter a Partner ID first'); return; }
  establish(peer.connect(pid, { reliable:true }));
});

/* Also connect lazily if user hits Speak/Listen without pressing Connect */
function ensureConn() {
  if (conn && conn.open) return true;
  const pid = ($('#partner-id').value || '').trim() || prompt('Enter Partner ID to connect:');
  if (!pid) return false;
  establish(peer.connect(pid, { reliable:true }));
  return true;
}

/* ---------- Speak flow ---------- */
$('#speak-btn').addEventListener('click', () => {
  if (!ensureConn()) return;
  hide($('#listen-section')); show($('#speak-section'));
});

$('#record-toggle').addEventListener('click', () => {
  // START
  if (!mediaRecorder || mediaRecorder.state !== 'recording') {
    navigator.mediaDevices.getUserMedia({ audio:true }).then(s=>{
      recordingStream = s;
      const mimeType = getSupportedMime(); // iOS first: audio/mp4
      try { mediaRecorder = new MediaRecorder(recordingStream, mimeType?{ mimeType }:{}); }
      catch(e){ alert('Recorder failed: '+e.message); return; }

      audioChunks = [];
      mediaRecorder.ondataavailable = e => { if (e.data && e.data.size>0) audioChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        recordingStream.getTracks().forEach(t=>t.stop());
        const finalMime = mediaRecorder.mimeType || mimeType || 'audio/webm';
        const blob = new Blob(audioChunks, { type: finalMime });
        sendAudioBlob(blob, finalMime);
        $('#record-toggle').textContent = 'Start Recording';
        setStatus('Line sent!');
      };
      mediaRecorder.start(100);
      $('#record-toggle').textContent = 'Stop Recording';
      setStatus('Recording‚Ä¶');
    }).catch(e=> alert('Microphone access denied: ' + e.message));
  } else {
    // STOP
    mediaRecorder.stop();
  }
});

/* ---------- Listen flow ---------- */
$('#listen-btn').addEventListener('click', () => {
  if (!ensureConn()) return;
  hide($('#speak-section')); show($('#listen-section'));
  // Prime autoplay on iOS by a user gesture
  const a = $('#audio-player'); a.muted = false; a.play().catch(()=>{});
  setStatus('Armed to listen‚Ä¶');
});

$('#accept-btn').addEventListener('click', () => {
  if (!conn || !conn.open) return;
  conn.send({ type: 'accept' });
  showChat();
});

/* ---------- Chat (text, photo, audio) ---------- */
$('#send-btn').addEventListener('click', () => {
  const input = $('#chat-input'); const msg = input.value.trim();
  if (!msg || !(conn && conn.open)) return;
  conn.send({ type:'message', data: msg });
  displayMessage(msg, true);
  input.value = '';
});

$('#photo-btn').addEventListener('click', () => $('#photo-input').click());
$('#photo-input').addEventListener('change', e => {
  const f = e.target.files?.[0]; if (!f || !(conn && conn.open)) return;
  f.arrayBuffer().then(buf => {
    const b = new Blob([buf], { type: f.type || 'image/jpeg' });
    appendImg(b, true);
    sendImg(b, f.name || 'photo.jpg');
    e.target.value = '';
  });
});

$('#audio-send-btn').addEventListener('click', () => {
  if (!chatRecorder || chatRecorder.state !== 'recording') {
    navigator.mediaDevices.getUserMedia({ audio:true }).then(s=>{
      chatStream = s;
      const mimeType = getSupportedMime();
      try { chatRecorder = new MediaRecorder(chatStream, mimeType?{ mimeType }:{}); }
      catch(e){ alert('Recorder failed: '+e.message); return; }
      chatChunks = [];
      chatRecorder.ondataavailable = e => { if (e.data && e.data.size>0) chatChunks.push(e.data); };
      chatRecorder.onstop = () => {
        chatStream.getTracks().forEach(t=>t.stop());
        const finalMime = chatRecorder.mimeType || mimeType || 'audio/webm';
        const blob = new Blob(chatChunks, { type: finalMime });
        sendChatAudioBlob(blob, finalMime);
        $('#audio-send-btn').textContent = 'üéôÔ∏è';
      };
      chatRecorder.start(100);
      $('#audio-send-btn').textContent = '‚èπÔ∏è';
      setStatus('Recording audio message‚Ä¶');
    }).catch(e=> alert('Mic blocked: ' + e.message));
  } else {
    chatRecorder.stop();
  }
});

/* ---------- Chunked send helpers ---------- */
function sendAudioBlob(blob, mimeType){
  if (!(conn && conn.open)) { alert('Not connected to a partner.'); return; }
  conn.send({ type:'audio-start', mime: mimeType, size: blob.size });
  const reader = new FileReader(); let offset = 0;
  reader.onload = (e) => {
    conn.send({ type:'audio-chunk', data:new Uint8Array(e.target.result) });
    offset += e.target.result.byteLength;
    if (offset < blob.size) readNext(); else conn.send({ type:'audio-end' });
  };
  function readNext(){ reader.readAsArrayBuffer(blob.slice(offset, offset + CHUNK_SIZE)); }
  readNext();
}

function sendChatAudioBlob(blob, mimeType){
  if (!(conn && conn.open)) return;
  conn.send({ type:'chat-audio-start', mime: mimeType, size: blob.size });
  const r = new FileReader(); let o = 0;
  r.onload = e => {
    conn.send({ type:'chat-audio-chunk', data:new Uint8Array(e.target.result) });
    o += e.target.result.byteLength;
    if (o < blob.size) read(); else conn.send({ type:'chat-audio-end' });
  };
  function read(){ r.readAsArrayBuffer(blob.slice(o, o + CHUNK_SIZE)); }
  read();
}

function sendImg(blob, name){
  if (!(conn && conn.open)) return;
  conn.send({ type:'image-start', mime: blob.type, name, size: blob.size });
  const r = new FileReader(); let o = 0;
  r.onload = e => {
    conn.send({ type:'image-chunk', data:new Uint8Array(e.target.result) });
    o += e.target.result.byteLength;
    if (o < blob.size) read(); else conn.send({ type:'image-end' });
  };
  function read(){ r.readAsArrayBuffer(blob.slice(o, o + CHUNK_SIZE)); }
  read();
}

/* ---------- Incoming data ---------- */
function handleData(msg){
  if (!msg || !msg.type) return;
  switch(msg.type){
    /* first-line audio */
    case 'audio-start':
      incomingChunks = []; incomingMime = msg.mime || 'audio/webm;codecs=opus';
      show($('#listen-section')); setStatus('Receiving a line‚Ä¶');
      break;
    case 'audio-chunk':
      incomingChunks.push(msg.data); break;
    case 'audio-end': {
      const blob = new Blob(incomingChunks, { type: incomingMime });
      playBlobInAudio(blob);
      show($('#accept-btn'));
      setStatus('Line received!');
      break;
    }

    /* accept ‚Üí open chat both sides */
    case 'accept':
      showChat(); break;

    /* text chat */
    case 'message':
      displayMessage(msg.data, false); break;

    /* chat audio */
    case 'chat-audio-start':
      rxChat = { parts: [], mime: msg.mime || 'audio/webm;codecs=opus' }; break;
    case 'chat-audio-chunk':
      rxChat.parts.push(msg.data); break;
    case 'chat-audio-end': {
      const blob = new Blob(rxChat.parts, { type: rxChat.mime });
      appendAudio(blob, false);
      rxChat = { parts: [], mime: 'audio/webm;codecs=opus' };
      break;
    }

    /* images */
    case 'image-start':
      rxImage = { parts: [], mime: msg.mime || 'image/jpeg', name: msg.name || 'photo.jpg' }; break;
    case 'image-chunk':
      rxImage.parts.push(msg.data); break;
    case 'image-end': {
      const blob = new Blob(rxImage.parts, { type: rxImage.mime });
      appendImg(blob, false);
      rxImage = { parts: [], mime: 'image/jpeg' };
      break;
    }
  }
}

/* ---------- Chat UI helpers ---------- */
function showChat(){
  hide($('#listen-section')); hide($('#speak-section')); show($('#match-section'));
}
function displayMessage(message, sent){
  const box = $('#chat-window');
  const d = document.createElement('div');
  d.className = 'chat-message ' + (sent?'sent':'received');
  d.textContent = message;
  box.appendChild(d);
  box.scrollTop = box.scrollHeight;
}
function appendImg(blob, sent){
  const box = $('#chat-window');
  const d = document.createElement('div');
  d.className = 'chat-message ' + (sent?'sent':'received');
  const img = document.createElement('img');
  img.src = URL.createObjectURL(blob);
  img.style.maxWidth = '220px'; img.style.borderRadius = '10px'; img.style.display = 'block';
  d.appendChild(img); box.appendChild(d); box.scrollTop = box.scrollHeight;
}
function appendAudio(blob, sent){
  const box = $('#chat-window');
  const d = document.createElement('div');
  d.className = 'chat-message ' + (sent?'sent':'received');
  const a = document.createElement('audio');
  a.controls = true; a.src = URL.createObjectURL(blob); a.preload = 'metadata'; a.style.display='block';
  d.appendChild(a); box.appendChild(d); box.scrollTop = box.scrollHeight;
}
</script>
</body>
</html> 