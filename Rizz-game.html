<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Rizzler: One-Way Push-to-Talk</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root{--gold:#e1bf78;--blue:#064D95;--green:#06954E;--red:#c40018;--redBright:#ff1e2d;}
    body{font-family:'Montserrat',sans-serif;background:#000;color:#fff;text-align:center;padding:20px;margin:0;overflow:hidden}
    .container{max-width:640px;margin:0 auto;border:2px solid var(--gold);border-radius:15px;padding:20px;box-shadow:0 0 20px var(--gold)}
    h1{font-size:2em;color:var(--gold);margin-bottom:10px}
    h1 .rizz{color:var(--redBright);display:inline-block;animation:rizzPulse 1.4s ease-in-out infinite}
    @keyframes rizzPulse{0%{transform:scale(1)}50%{transform:scale(1.15)}100%{transform:scale(1)}}
    button{padding:12px 22px;margin:8px;font-size:1em;border:none;border-radius:22px;cursor:pointer;transition:transform .2s;background:#333;color:#fff}
    button:hover{transform:scale(1.06)}
    #enter-btn{background:var(--red)}
    #speak-btn{background:var(--green)}
    #listen-btn{background:var(--blue)}
    #stop-btn{background:#6b6b6b}
    #next-btn{background:var(--red)}
    input[type="text"]{padding:10px;margin:5px;border:1px solid var(--gold);border-radius:10px;background:#222;color:#fff;width:calc(100% - 24px)}
    .hidden{display:none}
    #me-line{opacity:.95;margin:10px 0 6px}
    #status{opacity:.9;margin:8px 0 2px;min-height:1.2em}
    #remote-audio{margin:16px auto;width:100%}
    body::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle,rgba(225,191,120,.1) 0%,rgba(0,0,0,0) 100%);z-index:-1}
  </style>
</head>
<body>
  <div class="container">
    <h1>Rizzler: Unleash Your <span class="rizz">Rizz</span>!</h1>

    <div id="profile-form">
      <input type="text" id="display-name" placeholder="Your display name (optional)">
      <button id="enter-btn">Enter the Game</button>
      <div id="me-line" class="hidden"></div>
      <div id="status"></div>
    </div>

    <div id="main-section" class="hidden">
      <div style="margin-bottom:6px;">Choose your role each round:</div>
      <button id="speak-btn">Speak & Rizz</button>
      <button id="listen-btn">Listen & Get Rizzed</button>
      <button id="stop-btn" class="hidden">Stop</button>
      <button id="next-btn">Next Match</button>

      <audio id="remote-audio" controls autoplay playsinline class="hidden"></audio>
    </div>
  </div>

  <!-- PeerJS (for WebRTC) -->
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

  <!-- App logic (ES module): uses your firebase-config.js exporting `db` -->
  <script type="module">
    /********** Imports **********/
    import { db } from './firebase-config.js';
    import {
      ref, push, set, onValue, onDisconnect, remove, update, get,
      runTransaction, serverTimestamp, query, orderByChild, equalTo,
      limitToFirst, endAt
    } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js";

    /********** Config **********/
    const QUEUE_TTL_MS = 30000;
    const CLAIM_BATCH  = 8;

    /********** State **********/
    let peer;
    let myPeerId = null;
    let partnerId = null;

    let userProfile = {};
    let role = 'none'; // 'speaker' | 'listener' | 'none'
    let listeningArmed = false;

    // WebRTC call state
    let outgoingCall = null;        // when we initiate (speaker)
    let incomingCall = null;        // when we receive (listener)
    let localMicStream = null;      // mic stream while speaking
    let pendingRemoteStream = null; // if stream arrives before user arms listening

    // Firebase matchmaking refs
    let myTicketRef = null;
    let myPairRef = null;
    let requeueTimer = null;

    /********** DOM helpers **********/
    const $ = sel => document.querySelector(sel);
    const statusEl = $('#status');
    function setStatus(t){ statusEl.textContent = t || ''; }
    function show(el){ el.classList.remove('hidden'); }
    function hide(el){ el.classList.add('hidden'); }

    /********** PeerJS **********/
    async function initPeer(){
      peer = new Peer(undefined,{
        debug:2,
        config:{ iceServers:[
          {urls:'stun:stun.l.google.com:19302'},
          {urls:'stun:stun1.l.google.com:19302'},
          {urls:'stun:stun2.l.google.com:19302'}
        ]}
      });

      peer.on('open', id => {
        myPeerId = id;
        show($('#me-line'));
        $('#me-line').textContent = `Your ID: ${id}`;
        setStatus('Looking for a match…');
        joinQueue();
      });

      // LISTENER side: receive a call; answer with NO local stream (pure receive)
      peer.on('call', (call) => {
        // If we've chosen speaker role, we ignore incoming (one-way design)
        if (role === 'speaker') {
          // Politely reject to avoid loop
          try { call.close(); } catch {}
          return;
        }

        incomingCall?.close();
        incomingCall = call;
        role = (role === 'none') ? 'listener' : role;

        // Answer without a stream (receive-only)
        try { call.answer(); } catch { call.answer(); }

        call.on('stream', (remoteStream) => {
          pendingRemoteStream = remoteStream;
          attachRemoteIfArmed();
          setStatus('Receiving live audio…');
        });

        call.on('close', () => {
          teardownRemoteAudio();
          setStatus('Sender ended.');
          incomingCall = null;
        });

        call.on('error', () => {
          setStatus('Call error.');
          incomingCall = null;
        });
      });

      peer.on('disconnected', ()=>{ try{ peer.reconnect(); }catch {} });
      peer.on('error', (e)=>{ console.error('Peer error:', e); setStatus('Network issue. Reconnecting…'); });
    }

    /********** Matchmaking (Firebase) **********/
    function joinQueue(){
      myTicketRef = push(ref(db, 'queue'));
      set(myTicketRef, { peer: myPeerId, claimed: false, ts: serverTimestamp() });
      onDisconnect(myTicketRef).remove();

      myPairRef = ref(db, 'pairs/'+myPeerId);
      onDisconnect(myPairRef).remove();
      onValue(myPairRef, (snap)=>{
        const v = snap.val();
        if (v?.partner && !partnerId) {
          partnerId = v.partner;
          clearTimeout(requeueTimer);
          setStatus('Matched! Choose Speak or Listen.');
        }
      });

      cleanupStaleTickets(importCandidatesAndClaim);

      requeueTimer = setTimeout(() => {
        if (!partnerId) {
          setStatus('No match yet. Re-queuing…');
          safeRemove(myTicketRef);
          safeRemove(myPairRef);
          joinQueue();
        }
      }, QUEUE_TTL_MS);
    }

    function importCandidatesAndClaim(){
      const q = query(ref(db, 'queue'), orderByChild('claimed'), equalTo(false), limitToFirst(CLAIM_BATCH));
      get(q).then((snap)=>{
        const cands = [];
        snap.forEach(cs=>{
          const v = cs.val();
          if (v && v.peer && v.peer !== myPeerId && isFresh(v.ts)) {
            cands.push({ key: cs.key, peer: v.peer, ts: v.ts });
          }
        });
        tryClaim(cands, 0);
      });
    }

    function tryClaim(list, i){
      if (partnerId || i >= list.length) { setStatus('Waiting for someone…'); return; }
      const cand = list[i];
      const claimPath = ref(db, `queue/${cand.key}/claimed`);
      runTransaction(claimPath, cur => cur === false ? myPeerId : cur)
        .then(res=>{
          if (res.committed && res.snapshot.val() === myPeerId) {
            const updates = {};
            updates[`pairs/${myPeerId}`] = { partner: cand.peer, ts: Date.now() };
            updates[`pairs/${cand.peer}`] = { partner: myPeerId, ts: Date.now() };
            updates[`queue/${myTicketRef.key}`] = null;
            updates[`queue/${cand.key}`] = null;
            update(ref(db), updates).then(()=>{
              partnerId = cand.peer;
              clearTimeout(requeueTimer);
              setStatus('Matched! Choose Speak or Listen.');
            });
          } else {
            tryClaim(list, i+1);
          }
        })
        .catch(()=> tryClaim(list, i+1));
    }

    function cleanupStaleTickets(done){
      const cutoff = Date.now() - QUEUE_TTL_MS;
      const q = query(ref(db, 'queue'), orderByChild('ts'), endAt(cutoff), limitToFirst(25));
      get(q).then((snap)=>{
        const updates = {};
        snap.forEach(cs=>{
          const v = cs.val();
          if (v && v.ts && v.ts < cutoff) updates[`queue/${cs.key}`] = null;
        });
        if (Object.keys(updates).length) update(ref(db), updates).finally(()=>done && done());
        else done && done();
      });
    }

    function isFresh(ts){ return !ts || (Date.now() - ts) < QUEUE_TTL_MS; }
    function safeRemove(r){ try{ r && remove(r); }catch{} }

    /********** One-way Push-to-Talk **********/
    async function startSpeaking(){
      if (!partnerId) { setStatus('Matching… then you can talk.'); return; }
      if (role === 'listener') { setStatus('You’re the listener this round. Hit Next Match to switch.'); return; }
      if (localMicStream) return;

      try{
        localMicStream = await navigator.mediaDevices.getUserMedia({ audio:true });
      }catch(e){
        console.error(e);
        setStatus('Mic permission needed.');
        return;
      }

      // Place one-way call to partner (we send mic; we don’t expect remote audio)
      outgoingCall?.close();
      try{
        outgoingCall = peer.call(partnerId, localMicStream);
      }catch(e){
        console.error(e);
        setStatus('Call failed. Try again.');
        stopSpeaking();
        return;
      }

      role = 'speaker';
      $('#speak-btn').textContent = 'Speaking…';
      show($('#stop-btn'));
      setStatus('Sending live audio…');

      // If the other side calls us back (shouldn’t), we ignore in peer.on('call') because role==='speaker'
    }

    function stopSpeaking(){
      // stop local mic
      if (localMicStream){
        localMicStream.getTracks().forEach(t=>t.stop());
        localMicStream = null;
      }
      // end the call we placed
      try{ outgoingCall?.close(); }catch{}
      outgoingCall = null;

      $('#speak-btn').textContent = 'Speak & Rizz';
      hide($('#stop-btn'));
      setStatus('Live message ended.');
      // keep role, but no active stream now
    }

    function armListening(){
      if (role === 'speaker') { setStatus('You’re the speaker this round. Hit Stop or Next Match to switch.'); return; }
      role = 'listener';
      listeningArmed = true;

      // prepare audio element to satisfy autoplay policies
      const a = $('#remote-audio');
      show(a);
      a.muted = false;
      a.play().catch(()=>{}); // pre-warm

      attachRemoteIfArmed();
      setStatus(partnerId ? 'Ready to hear a live line…' : 'Armed to listen… waiting for match');
    }

    function attachRemoteIfArmed(){
      if (!listeningArmed || !pendingRemoteStream) return;
      const a = $('#remote-audio');
      a.srcObject = pendingRemoteStream;
      a.play().catch(()=>{}); // should be allowed after user gesture
      pendingRemoteStream = null;
    }

    function teardownRemoteAudio(){
      const a = $('#remote-audio');
      try { a.pause(); } catch {}
      a.srcObject = null;
      hide(a);
    }

    function nextMatch(){
      // hang up anything + reset roles
      stopSpeaking();
      try{ incomingCall?.close(); }catch{}
      incomingCall = null;
      teardownRemoteAudio();

      role = 'none';
      listeningArmed = false;
      pendingRemoteStream = null;

      // clear pairing and requeue
      partnerId = null;
      setStatus('Re-matching…');
      joinQueue();
    }

    /********** UI **********/
    $('#enter-btn').addEventListener('click', async () => {
      userProfile.name = ($('#display-name').value || '').trim() || 'Rizzler';
      hide($('#profile-form'));
      show($('#main-section'));
      setStatus('Initializing…');
      await initPeer();
    });

    $('#speak-btn').addEventListener('click', () => {
      if (localMicStream) return; // already speaking
      startSpeaking();
    });

    $('#stop-btn').addEventListener('click', () => {
      stopSpeaking();
    });

    $('#listen-btn').addEventListener('click', () => {
      armListening();
    });

    $('#next-btn').addEventListener('click', () => nextMatch());
  </script>
</body>
</html>