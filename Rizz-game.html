<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Rizzler</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{--gold:#e1bf78;--blue:#064D95;--green:#06954E;--red:#c40018;--redBright:#ff1e2d;}
  body{font-family:'Montserrat',sans-serif;background:#000;color:#fff;text-align:center;padding:20px;margin:0}
  .container{max-width:680px;margin:0 auto;border:2px solid var(--gold);border-radius:14px;padding:18px;box-shadow:0 0 18px var(--gold)}
  h1{font-size:1.9em;color:var(--gold);margin:0 0 10px}
  .pulse{color:var(--redBright);display:inline-block;animation:pulse 1.4s ease-in-out infinite}
  @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.15)}100%{transform:scale(1)}}
  button{padding:12px 22px;margin:8px;font-size:1.05em;border:none;border-radius:24px;cursor:pointer;transition:transform .2s,box-shadow .2s;color:#fff}
  button:hover{transform:scale(1.05);box-shadow:0 0 10px currentColor}
  #speak-btn{background:var(--green)}
  #listen-btn{background:var(--blue)}
  #accept-btn{background:var(--red)}
  #send-btn,#audio-send-btn{background:var(--green)}
  #photo-btn{background:var(--blue)}
  input[type="text"]{padding:10px;margin:5px;border:1px solid var(--gold);border-radius:10px;background:#222;color:#fff}
  .hidden{display:none}
  #status{opacity:.95;min-height:1.6em;margin:6px 0 10px}
  #status.error{color:#ff5b6e}
  #status.ok{color:#9bffa6}
  #badge{display:inline-block;padding:2px 8px;border-radius:10px;border:1px solid #555;background:#222;font-size:.8em;margin-bottom:8px}
  #audio-player{margin:12px auto;width:100%}
  #chat-window{height:260px;overflow-y:auto;border:1px solid var(--gold);border-radius:10px;padding:10px;background:#111;margin-bottom:10px;text-align:left}
  .chat-message{padding:8px 10px;margin:6px 0;border-radius:12px;max-width:85%;word-wrap:break-word;animation:slideIn .25s ease-out;display:inline-block}
  .sent{background:var(--green);margin-left:auto}
  .received{background:var(--blue);margin-right:auto}
  @keyframes slideIn{from{transform:translateY(12px);opacity:0}to{transform:translateY(0);opacity:1}}
  .row{display:flex;gap:8px;justify-content:center;align-items:center;flex-wrap:wrap}
  .tiny{font-size:.9em;opacity:.85}
</style>
</head>
<body>
<div class="container">
  <h1>Unleash Your <span class="pulse">Rizz</span></h1>

  <div id="badge" class="hidden"></div>
  <div id="status">Initializing‚Ä¶</div>

  <!-- Main actions -->
  <div id="main" class="hidden">
    <button id="speak-btn">Speak & Rizz</button>
    <button id="listen-btn">Listen & Get Rizzed</button>
  </div>

  <!-- Speak flow -->
  <div id="speak-section" class="hidden">
    <p><strong>Record your line:</strong></p>
    <button id="record-toggle">Start Recording</button>
    <div class="tiny">Tap once to start; tap again to stop & send.</div>
  </div>

  <!-- Listen flow -->
  <div id="listen-section" class="hidden">
    <audio id="audio-player" controls crossorigin="anonymous" playsinline></audio><br>
    <button id="accept-btn" class="hidden">Accept & Match</button>
    <div class="tiny">Your match‚Äôs line will play here.</div>
  </div>

  <!-- Match / Chat -->
  <div id="match-section" class="hidden">
    <h2>Chat</h2>
    <div id="chat-window"></div>
    <div class="row">
      <input type="text" id="chat-input" placeholder="Type your message‚Ä¶" style="flex:1;min-width:180px">
      <button id="send-btn">Send</button>
      <input id="photo-input" class="hidden" type="file" accept="image/*" capture="environment">
      <button id="photo-btn" title="Send photo">üì∑</button>
      <button id="audio-send-btn" title="Record/send audio">üéôÔ∏è</button>
    </div>
  </div>
</div>

<!-- PeerJS -->
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

<!-- App -->
<script type="module">
/* ====== UI helpers ====== */
const $ = s => document.querySelector(s);
const setStatus = (s, cls) => { const el=$('#status'); el.textContent=s||''; el.className = cls?(''+cls):''; };
const show = el => el.classList.remove('hidden');
const hide = el => el.classList.add('hidden');

/* ====== Global state ====== */
let peer, conn, myPeerId=null, partnerId=null;

let mediaRecorder=null, recordingStream=null, audioChunks=[];
let chatRecorder=null, chatStream=null, chatChunks=[];
let incomingChunks=[], incomingMime='audio/webm;codecs=opus';
let rxChat={parts:[],mime:'audio/webm;codecs=opus'};
let rxImage={parts:[],mime:'image/jpeg',name:'photo.jpg'};

const CHUNK_SIZE = 16*1024;

/* ====== Safari-friendly MIME ====== */
function pickMime(){
  const t=['audio/mp4','audio/webm;codecs=opus','audio/webm','audio/ogg;codecs=opus'];
  for (const x of t) if (window.MediaRecorder?.isTypeSupported?.(x)) return x;
  return '';
}
function playBlob(b){
  const a=$('#audio-player'); const url=URL.createObjectURL(b);
  a.srcObject=null; a.src=url; a.load(); a.play().catch(()=>{});
}

/* ====== PeerJS ====== */
function initPeer(){
  return new Promise(resolve=>{
    peer = new Peer(undefined,{
      debug:2,
      config:{ iceServers:[
        {urls:'stun:stun.l.google.com:19302'},
        {urls:'stun:stun1.l.google.com:19302'},
        {urls:'stun:stun2.l.google.com:19302'}
      ]}
    });

    peer.on('open', id => { myPeerId=id; resolve(); });
    peer.on('connection', c => establish(c));
    peer.on('call', c => { try{c.close();}catch{} });
    peer.on('disconnected', ()=>{ try{peer.reconnect();}catch{} });
    peer.on('error', e => console.error('Peer error:', e));
  });
}

function establish(c){
  if (conn && conn.open && c.peer !== conn.peer) { try{c.close();}catch{}; return; }
  conn = c;
  conn.on('open', () => {
    setStatus('Matched! Choose Speak or Listen.', 'ok');
    show($('#main'));
  });
  conn.on('data', handleData);
  conn.on('close', onDisconnect);
  conn.on('error', onDisconnect);
}

function onDisconnect(){
  setStatus('Partner disconnected. Matching again‚Ä¶');
  conn=null; partnerId=null;
  hide($('#speak-section')); hide($('#listen-section')); hide($('#match-section'));
  show($('#main'));
  if (matchmakingOK) joinQueue(); // re-queue if firebase ok
}

/* ====== Firebase dynamic load + health check ====== */
let db=null, rtdb=null, matchmakingOK=false;

async function loadFirebase(){
  try{
    const cfg = await import('./firebase-config.js'); // your file (must export `db`)
    db   = cfg.db;
    rtdb = await import('https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js');

    // HEALTH CHECK: try a write+read+delete under /health
    const testRef = rtdb.ref(db, 'health/' + Math.random().toString(36).slice(2));
    await rtdb.set(testRef, {ok:true, ts: Date.now()});
    const snap = await rtdb.get(testRef);
    if (!snap.exists()) throw new Error('RTDB read-back failed');
    await rtdb.remove(testRef);

    matchmakingOK = true;
    $('#badge').textContent = 'Auto-match: ON'; show($('#badge'));
    setStatus('Connecting to the pool‚Ä¶','ok');
    return true;
  }catch(err){
    console.warn('Firebase unavailable:', err);
    matchmakingOK = false;
    $('#badge').textContent = 'Auto-match: OFF (manual fallback)'; show($('#badge'));
    setStatus('Auto-match is off. You can still connect via prompt when you tap Speak/Listen.', 'error');
    return false;
  }
}

/* ====== Auto-match (queue) ====== */
const QUEUE_TTL_MS=30000, CLAIM_BATCH=8;
let myTicketRef=null, myPairRef=null, requeueTimer=null;

function isFresh(ts){ return !ts || (Date.now()-ts) < QUEUE_TTL_MS; }
function clearTimer(){ if(requeueTimer){ clearTimeout(requeueTimer); requeueTimer=null; } }

function joinQueue(){
  if (!matchmakingOK || !myPeerId) return;

  const { ref, push, set, onValue, onDisconnect, remove, update, get,
          runTransaction, serverTimestamp, query, orderByChild, equalTo,
          limitToFirst, endAt } = rtdb;

  setStatus('Finding a random match‚Ä¶');

  // 1) my ticket
  myTicketRef = push(ref(db,'queue'));
  set(myTicketRef,{peer:myPeerId,claimed:false,ts:serverTimestamp()});
  onDisconnect(myTicketRef).remove();

  // 2) watch if someone pairs us
  myPairRef = ref(db,'pairs/'+myPeerId);
  onDisconnect(myPairRef).remove();
  onValue(myPairRef, snap=>{
    const v=snap.val();
    if (v?.partner && !partnerId){
      partnerId=v.partner;
      clearTimer();
      maybeConnect();
    }
  });

  // 3) clean & try claim
  cleanup(()=>queryAndClaim());

  // 4) auto requeue if no partner
  clearTimer();
  requeueTimer=setTimeout(()=>{
    if (!partnerId){
      safeRemove(myTicketRef); safeRemove(myPairRef);
      joinQueue();
    }
  }, QUEUE_TTL_MS);

  function safeRemove(r){ try{ r && remove(r); }catch{} }
  function cleanup(done){
    const cutoff=Date.now()-QUEUE_TTL_MS;
    const q=query(ref(db,'queue'), orderByChild('ts'), endAt(cutoff), limitToFirst(25));
    get(q).then(snap=>{
      const updates={};
      snap.forEach(cs=>{
        const v=cs.val();
        if (v && v.ts && v.ts < cutoff) updates[`queue/${cs.key}`] = null;
      });
      if (Object.keys(updates).length) update(ref(db),updates).finally(()=>done&&done());
      else done&&done();
    });
  }
  function queryAndClaim(){
    const q=query(ref(db,'queue'), orderByChild('claimed'), equalTo(false), limitToFirst(CLAIM_BATCH));
    get(q).then(snap=>{
      const cands=[];
      snap.forEach(cs=>{
        const v=cs.val();
        if (v && v.peer && v.peer!==myPeerId && isFresh(v.ts)) cands.push({key:cs.key,peer:v.peer,ts:v.ts});
      });
      tryClaim(cands,0);
    });
  }
  function tryClaim(list,i){
    if (partnerId || i>=list.length){ setStatus('Waiting for someone‚Ä¶'); return; }
    const cand=list[i];
    const claimPath=ref(db,`queue/${cand.key}/claimed`);
    runTransaction(claimPath, cur => (cur===false ? myPeerId : cur))
      .then(res=>{
        if (res.committed && res.snapshot.val()===myPeerId){
          const updates={};
          updates[`pairs/${myPeerId}`] = {partner:cand.peer, ts:Date.now()};
          updates[`pairs/${cand.peer}`] = {partner:myPeerId, ts:Date.now()};
          updates[`queue/${myTicketRef.key}`] = null;
          updates[`queue/${cand.key}`] = null;
          update(ref(db),updates).then(()=>{
            partnerId=cand.peer; clearTimer(); maybeConnect();
          });
        } else {
          tryClaim(list,i+1);
        }
      })
      .catch(()=> tryClaim(list,i+1));
  }
}

function maybeConnect(){
  if (!partnerId || !myPeerId) return;
  if (conn && conn.open) return;
  // deterministic initiator (lexicographic)
  if (myPeerId < partnerId){
    establish(peer.connect(partnerId, {reliable:true}));
  }
  // else wait for inbound
}

/* ====== Manual fallback connect (prompt) ====== */
function ensureManualConnection(){
  if (conn && conn.open) return true;
  const pid = prompt('Enter your partner‚Äôs ID');
  if (!pid) return false;
  establish(peer.connect(pid, {reliable:true}));
  return true;
}

/* ====== Buttons ====== */
$('#speak-btn').addEventListener('click', ()=>{
  if (matchmakingOK){
    if (!conn || !conn.open){ setStatus('Matching‚Ä¶'); return; }
  } else {
    if (!ensureManualConnection()) return;
  }
  hide($('#listen-section')); show($('#speak-section'));
});
$('#listen-btn').addEventListener('click', ()=>{
  if (matchmakingOK){
    if (!conn || !conn.open){ setStatus('Matching‚Ä¶'); return; }
  } else {
    if (!ensureManualConnection()) return;
  }
  hide($('#speak-section')); show($('#listen-section'));
  const a=$('#audio-player'); a.muted=false; a.play().catch(()=>{}); // iOS priming
});

/* ====== Speak record/send ====== */
$('#record-toggle').addEventListener('click', ()=>{
  if (!conn || !conn.open){ setStatus('Not connected yet‚Ä¶'); return; }

  if (!mediaRecorder || mediaRecorder.state!=='recording'){
    navigator.mediaDevices.getUserMedia({audio:true}).then(s=>{
      recordingStream=s;
      const mt=pickMime();
      try{ mediaRecorder=new MediaRecorder(s, mt?{mimeType:mt}:{}) }catch(e){ alert('Recorder failed: '+e.message); return; }
      audioChunks=[];
      mediaRecorder.ondataavailable=e=>{ if (e.data && e.data.size>0) audioChunks.push(e.data); };
      mediaRecorder.onstop=()=>{
        recordingStream.getTracks().forEach(t=>t.stop());
        const finalMime=mediaRecorder.mimeType || mt || 'audio/webm';
        const blob=new Blob(audioChunks,{type:finalMime});
        sendAudio(blob, finalMime);
        $('#record-toggle').textContent='Start Recording';
        setStatus('Line sent!');
      };
      mediaRecorder.start(100);
      $('#record-toggle').textContent='Stop Recording';
      setStatus('Recording‚Ä¶');
    }).catch(e=> alert('Mic access denied: '+e.message));
  }else{
    mediaRecorder.stop();
  }
});

function sendAudio(blob,mime){
  conn.send({type:'audio-start', mime, size:blob.size});
  const r=new FileReader(); let o=0;
  r.onload=e=>{
    conn.send({type:'audio-chunk', data:new Uint8Array(e.target.result)});
    o+=e.target.result.byteLength;
    if (o<blob.size) read(); else conn.send({type:'audio-end'});
  };
  function read(){ r.readAsArrayBuffer(blob.slice(o, o+CHUNK_SIZE)); }
  read();
}

/* ====== Accept -> Chat ====== */
$('#accept-btn').addEventListener('click', ()=>{
  if (!conn || !conn.open) return;
  conn.send({type:'accept'});
  openChat();
});
function openChat(){
  hide($('#listen-section')); hide($('#speak-section')); show($('#match-section'));
}

/* ====== Chat (text/photo/audio) ====== */
$('#send-btn').addEventListener('click', ()=>{
  const input=$('#chat-input'); const msg=input.value.trim();
  if (!msg || !(conn&&conn.open)) return;
  conn.send({type:'msg', data:msg});
  addMsg(msg,true); input.value='';
});
$('#photo-btn').addEventListener('click', ()=> $('#photo-input').click());
$('#photo-input').addEventListener('change', e=>{
  const f=e.target.files?.[0]; if (!f || !(conn&&conn.open)) return;
  f.arrayBuffer().then(buf=>{
    const b=new Blob([buf],{type:f.type||'image/jpeg'});
    addImg(b,true); sendImg(b, f.name||'photo.jpg'); e.target.value='';
  });
});
$('#audio-send-btn').addEventListener('click', ()=>{
  if (!chatRecorder || chatRecorder.state!=='recording'){
    navigator.mediaDevices.getUserMedia({audio:true}).then(s=>{
      chatStream=s;
      const mt=pickMime();
      try{ chatRecorder=new MediaRecorder(s, mt?{mimeType:mt}:{}) }catch(e){ alert('Recorder failed: '+e.message); return; }
      chatChunks=[];
      chatRecorder.ondataavailable=e=>{ if (e.data && e.data.size>0) chatChunks.push(e.data); };
      chatRecorder.onstop=()=>{
        chatStream.getTracks().forEach(t=>t.stop());
        const finalMime=chatRecorder.mimeType || mt || 'audio/webm';
        const blob=new Blob(chatChunks,{type:finalMime});
        sendChatAudio(blob, finalMime);
        $('#audio-send-btn').textContent='üéôÔ∏è';
      };
      chatRecorder.start(100);
      $('#audio-send-btn').textContent='‚èπÔ∏è';
      setStatus('Recording audio message‚Ä¶');
    }).catch(e=> alert('Mic blocked: '+e.message));
  }else{
    chatRecorder.stop();
  }
});

function sendChatAudio(blob,mime){
  conn.send({type:'chat-start', mime, size:blob.size});
  const r=new FileReader(); let o=0;
  r.onload=e=>{
    conn.send({type:'chat-chunk', data:new Uint8Array(e.target.result)});
    o+=e.target.result.byteLength;
    if (o<blob.size) read(); else conn.send({type:'chat-end'});
  };
  function read(){ r.readAsArrayBuffer(blob.slice(o, o+CHUNK_SIZE)); }
  read();
}
function sendImg(blob,name){
  conn.send({type:'img-start', mime:blob.type, name, size:blob.size});
  const r=new FileReader(); let o=0;
  r.onload=e=>{
    conn.send({type:'img-chunk', data:new Uint8Array(e.target.result)});
    o+=e.target.result.byteLength;
    if (o<blob.size) read(); else conn.send({type:'img-end'});
  };
  function read(){ r.readAsArrayBuffer(blob.slice(o, o+CHUNK_SIZE)); }
  read();
}

/* ====== Incoming data ====== */
function handleData(msg){
  if (!msg || !msg.type) return;
  switch(msg.type){
    case 'audio-start':
      incomingChunks=[]; incomingMime=msg.mime||'audio/webm;codecs=opus';
      show($('#listen-section')); setStatus('Receiving a line‚Ä¶'); break;
    case 'audio-chunk':
      incomingChunks.push(msg.data); break;
    case 'audio-end':
      playBlob(new Blob(incomingChunks,{type:incomingMime}));
      show($('#accept-btn')); setStatus('Line received!'); break;

    case 'accept': openChat(); break;

    case 'msg': addMsg(msg.data,false); break;

    case 'chat-start': rxChat={parts:[],mime:msg.mime||'audio/webm;codecs=opus'}; break;
    case 'chat-chunk': rxChat.parts.push(msg.data); break;
    case 'chat-end': addAudio(new Blob(rxChat.parts,{type:rxChat.mime}),false); rxChat={parts:[],mime:'audio/webm;codecs=opus'}; break;

    case 'img-start': rxImage={parts:[],mime:msg.mime||'image/jpeg',name:msg.name||'photo.jpg'}; break;
    case 'img-chunk': rxImage.parts.push(msg.data); break;
    case 'img-end': addImg(new Blob(rxImage.parts,{type:rxImage.mime}),false); rxImage={parts:[],mime:'image/jpeg',name:'photo.jpg'}; break;
  }
}

function addMsg(m, sent){
  const box=$('#chat-window'); const d=document.createElement('div');
  d.className='chat-message '+(sent?'sent':'received'); d.textContent=m;
  box.appendChild(d); box.scrollTop=box.scrollHeight;
}
function addImg(b, sent){
  const box=$('#chat-window'); const d=document.createElement('div');
  d.className='chat-message '+(sent?'sent':'received');
  const i=document.createElement('img'); i.src=URL.createObjectURL(b); i.style.maxWidth='220px'; i.style.borderRadius='10px';
  d.appendChild(i); box.appendChild(d); box.scrollTop=box.scrollHeight;
}
function addAudio(b, sent){
  const box=$('#chat-window'); const d=document.createElement('div');
  d.className='chat-message '+(sent?'sent':'received');
  const a=document.createElement('audio'); a.controls=true; a.src=URL.createObjectURL(b); a.preload='metadata';
  d.appendChild(a); box.appendChild(d); box.scrollTop=box.scrollHeight;
}

/* ====== Boot ====== */
(async ()=>{
  setStatus('Starting‚Ä¶');
  await initPeer();
  const ok = await loadFirebase();   // tries to load + write + read + delete
  show($('#main'));
  if (ok){ joinQueue(); }
})();
</script>
</body>
</html>