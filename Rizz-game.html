<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rizzler ‚Äî Audio Swipe</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{--gold:#e1bf78;--blue:#064D95;--green:#06954E;--red:#c40018;--ink:#111;}
  *{box-sizing:border-box}
  body{margin:0;background:#000;color:#fff;font-family:'Montserrat',sans-serif}
  .wrap{max-width:840px;margin:0 auto;padding:16px}
  .card{border:2px solid var(--gold);border-radius:14px;background:#0b0b0b;box-shadow:0 0 18px rgba(225,191,120,.5);padding:14px;margin:10px 0}
  h1{margin:2px 0 10px;color:var(--gold);font-size:1.7rem;text-align:center}
  label{display:block;margin:8px 0 4px}
  input[type="text"]{width:100%;padding:10px;border:1px solid var(--gold);border-radius:10px;background:#1c1c1c;color:#fff}
  button{padding:12px 16px;border:none;border-radius:24px;color:#fff;background:#333;cursor:pointer;margin:6px 6px 0 0;font-size:1rem;transition:transform .15s,box-shadow .15s}
  button:hover{transform:scale(1.04);box-shadow:0 0 10px currentColor}
  .btn-green{background:var(--green)} .btn-blue{background:var(--blue)} .btn-red{background:var(--red)}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .center{display:flex;justify-content:center}
  audio{width:100%;background:#000;margin:6px 0}
  #status{min-height:1.3em;opacity:.95;margin-top:6px}
  #status.ok{color:#9bffa6} #status.err{color:#ff7b86}
  #browse-none{opacity:.85}
  #chat{max-height:360px;overflow-y:auto;border:1px solid var(--gold);border-radius:10px;background:var(--ink);padding:10px;margin-top:10px}
  .bubble{display:inline-block;max-width:78%; padding:8px 10px;margin:6px 0;border-radius:12px;animation:fade .2s ease-out}
  .me{background:var(--green);margin-left:auto} .them{background:var(--blue);margin-right:auto}
  .bubble img{max-width:220px;border-radius:10px;display:block}
  @keyframes fade{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}
  .muted{opacity:.7}
</style>
</head>
<body>
<div class="wrap">
  <h1>Rizzler ‚Äî Audio Swipe</h1>

  <!-- Onboarding -->
  <div class="card" id="onboard">
    <label>Your display name</label>
    <input id="name" type="text" placeholder="e.g., Venus" />
    <div class="row">
      <button id="go" class="btn-green">Start</button>
      <div id="status" class="muted">Say your best line, then browse others.</div>
    </div>
  </div>

  <!-- Record my line -->
  <div class="card" id="record" hidden>
    <strong>Record your pick-up line</strong>
    <div class="row">
      <button id="rec-btn" class="btn-green">üéôÔ∏è Start recording</button>
      <button id="submit-line" class="btn-blue" disabled>Upload line</button>
      <span id="rec-hint" class="muted">Tap to start, tap again to stop.</span>
    </div>
    <audio id="my-preview" controls hidden></audio>
  </div>

  <!-- Browse audio cards -->
  <div class="card" id="browse" hidden>
    <strong>Browse daters</strong>
    <audio id="card-audio" controls></audio>
    <div id="card-meta" class="muted"></div>
    <div class="row center">
      <button id="pass" class="btn-red">Pass</button>
      <button id="like" class="btn-green">Like</button>
      <button id="next" class="btn-blue">Next</button>
    </div>
    <div id="browse-none" class="center muted" hidden>No more lines right now ‚Äî try again in a bit.</div>
  </div>

  <!-- Match + chat -->
  <div class="card" id="chat-card" hidden>
    <strong id="chat-title">Match!</strong>
    <div id="chat"></div>
    <div class="row">
      <input id="msg" type="text" placeholder="Type a message‚Ä¶">
      <button id="send" class="btn-green">Send</button>

      <input id="photo" type="file" accept="image/*" hidden>
      <button id="send-photo" class="btn-blue">üì∑ Photo</button>

      <button id="send-voice" class="btn-blue">üéôÔ∏è Voice</button>
    </div>
  </div>
</div>

<script type="module">
/* ===== Firebase (your config file) ===== */
import { app, db } from './firebase-config.js';
import {
  ref, push, set, get, update, serverTimestamp,
  onChildAdded, onValue, query, orderByChild, limitToLast
} from "https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js";
import {
  getStorage, ref as sRef, uploadBytes, getDownloadURL
} from "https://www.gstatic.com/firebasejs/10.12.3/firebase-storage.js";

/* ===== Setup ===== */
const storage = getStorage(app);

/* ===== Helpers ===== */
const $ = s => document.querySelector(s);
const uid = () => (crypto.randomUUID? crypto.randomUUID(): Math.random().toString(36).slice(2));
const setStatus = (t, cls='') => { const el=$('#status'); el.textContent=t||''; el.className=cls; };
function ts(){ return Date.now(); }

/* ===== State ===== */
let me = { id: uid(), name: "" };
let rec, recChunks=[], recStream=null;
let feed = []; let feedPos = -1; let currentCard = null;
let matchId = null;

/* ===== Onboarding ===== */
$('#go').addEventListener('click', async ()=>{
  me.name = ($('#name').value||'').trim() || 'Rizzler';
  $('#onboard').hidden = true;
  $('#record').hidden = false;
  await update(ref(db, `users/${me.id}`), { name: me.name, active: true, ts: ts() });
});

/* ===== Recording ===== */
function bestMime(){
  const types = ['audio/webm;codecs=opus','audio/mp4','audio/webm','audio/ogg;codecs=opus'];
  for (const t of types) if (window.MediaRecorder?.isTypeSupported?.(t)) return t;
  return '';
}
$('#rec-btn').addEventListener('click', async ()=>{
  if (!rec || rec.state === 'inactive'){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({audio:true});
      recStream = stream;
      const mt = bestMime();
      recChunks = [];
      rec = new MediaRecorder(stream, mt?{mimeType:mt}:{});
      rec.ondataavailable = e=>{ if (e.data && e.data.size) recChunks.push(e.data); };
      rec.onstop = ()=>{
        recStream.getTracks().forEach(t=>t.stop());
        const blob = new Blob(recChunks, {type: rec.mimeType || mt || 'audio/webm'});
        $('#my-preview').hidden = false;
        $('#my-preview').src = URL.createObjectURL(blob);
        $('#submit-line').disabled = false;
        setStatus('Ready to upload your line.','ok');
      };
      rec.start(100);
      $('#rec-btn').textContent = '‚èπÔ∏è Stop';
      setStatus('Recording‚Ä¶');
    }catch(e){
      setStatus('Microphone blocked ‚Äî enable mic permissions.', 'err');
    }
  }else{
    rec.stop();
    $('#rec-btn').textContent = 'üéôÔ∏è Start recording';
  }
});

/* ===== Upload to Storage + write to RTDB ===== */
$('#submit-line').addEventListener('click', async ()=>{
  if (!recChunks.length){ setStatus('Record first.','err'); return; }
  try{
    setStatus('Uploading‚Ä¶');
    const mime = rec.mimeType || bestMime() || 'audio/webm';
    const blob = new Blob(recChunks, {type:mime});
    // 1) upload file to Storage
    const key = `${me.id}-${Date.now()}.webm`; // extension is fine for opus/mp4 too
    const fileRef = sRef(storage, `lines/${me.id}/${key}`);
    await uploadBytes(fileRef, blob, { contentType: mime });
    const url = await getDownloadURL(fileRef);

    // 2) save/overwrite line reference in RTDB
    await set(ref(db, `lines/${me.id}`), {
      uid: me.id, name: me.name, mime, url, ts: serverTimestamp()
    });

    // 3) proceed to feed
    $('#record').hidden = true;
    await loadFeed();
    $('#browse').hidden = false;
    setStatus('Line uploaded. Start browsing!','ok');
  }catch(err){
    console.error(err);
    setStatus('Upload failed. Check your Firebase Storage rules & CORS.', 'err');
  }
});

/* ===== Feed ===== */
async function loadFeed(){
  const snap = await get(query(ref(db,'lines'), orderByChild('ts'), limitToLast(40)));
  feed = [];
  snap.forEach(s=>{
    const v = s.val();
    if (v && v.uid !== me.id) feed.push(v);
  });
  feed.sort((a,b)=>(b.ts||0)-(a.ts||0));
  feedPos = -1;
  nextCard();
}
function nextCard(){
  $('#browse-none').hidden = true;
  for (let i=feedPos+1; i<feed.length; i++){
    const v = feed[i];
    currentCard = v;
    feedPos = i;
    renderCard(v);
    return;
  }
  currentCard = null;
  $('#card-audio').src = '';
  $('#card-meta').textContent = '';
  $('#browse-none').hidden = false;
}
function renderCard(v){
  $('#card-audio').src = v.url; // stream directly from Storage
  $('#card-meta').textContent = `${v.name||'Rizzler'} ‚Ä¢ tap play to listen`;
}
$('#next').addEventListener('click', nextCard);
$('#pass').addEventListener('click', async ()=>{
  if (!currentCard) return;
  await set(ref(db, `passes/${me.id}/${currentCard.uid}`), true);
  nextCard();
});
$('#like').addEventListener('click', async ()=>{
  if (!currentCard) return;
  await set(ref(db, `likes/${me.id}/${currentCard.uid}`), true);
  const back = await get(ref(db, `likes/${currentCard.uid}/${me.id}`));
  if (back.exists()){
    const a = [me.id, currentCard.uid].sort();
    matchId = `${a[0]}_${a[1]}`;
    await update(ref(db, `matches/${matchId}`), { a:a[0], b:a[1], ts: serverTimestamp() });
    openChat(currentCard);
  }else{
    setStatus('Like sent ‚Äî if they like you back, you‚Äôll match!','ok');
    nextCard();
  }
});

/* ===== Chat ===== */
let chatUnsub = null;
function openChat(partner){
  $('#browse').hidden = true;
  $('#chat-card').hidden = false;
  $('#chat-title').textContent = `Chat with ${partner.name||'Match'}`;
  $('#chat').innerHTML = '';
  if (chatUnsub) chatUnsub();
  chatUnsub = onChildAdded(ref(db, `chats/${matchId}/messages`), (snap)=> renderMsg(snap.val()));
}
function renderMsg(m){
  const box = $('#chat');
  const b = document.createElement('div');
  b.className = 'bubble ' + (m.from===me.id ? 'me':'them');
  if (m.type==='text'){
    b.textContent = m.text;
  } else if (m.type==='image'){
    const img = document.createElement('img');
    img.src = m.url; // served from Storage
    b.appendChild(img);
  } else if (m.type==='audio'){
    const a = document.createElement('audio');
    a.controls = true; a.src = m.url;
    b.appendChild(a);
  }
  box.appendChild(b); box.scrollTop = box.scrollHeight;
}
/* send text */
$('#send').addEventListener('click', async ()=>{
  const t = ($('#msg').value||'').trim(); if (!t || !matchId) return;
  await push(ref(db, `chats/${matchId}/messages`), { from: me.id, type:'text', text:t, ts: serverTimestamp() });
  $('#msg').value = '';
});

/* send photo (to Storage) */
$('#send-photo').addEventListener('click', ()=> $('#photo').click());
$('#photo').addEventListener('change', async (e)=>{
  const f = e.target.files?.[0]; if (!f || !matchId) return;
  try{
    const key = `${me.id}-${Date.now()}-${f.name}`;
    const r = sRef(storage, `chat/${matchId}/${key}`);
    await uploadBytes(r, f, { contentType: f.type||'image/jpeg' });
    const url = await getDownloadURL(r);
    await push(ref(db, `chats/${matchId}/messages`), { from: me.id, type:'image', url, ts: serverTimestamp() });
  }catch(err){ alert('Photo upload failed.'); }
  e.target.value = '';
});

/* send voice memo (to Storage) */
let memoRec=null, memoChunks=[], memoStream=null;
$('#send-voice').addEventListener('click', async ()=>{
  if (!matchId) return;
  if (!memoRec || memoRec.state==='inactive'){
    try{
      const s = await navigator.mediaDevices.getUserMedia({audio:true});
      memoStream = s; memoChunks = [];
      const mt = bestMime();
      memoRec = new MediaRecorder(s, mt?{mimeType:mt}:{});
      memoRec.ondataavailable = e=>{ if (e.data && e.data.size) memoChunks.push(e.data); };
      memoRec.onstop = async ()=>{
        memoStream.getTracks().forEach(t=>t.stop());
        const mime = memoRec.mimeType || mt || 'audio/webm';
        const blob = new Blob(memoChunks, {type:mime});
        try{
          const key = `${me.id}-${Date.now()}.webm`;
          const r = sRef(storage, `chat/${matchId}/${key}`);
          await uploadBytes(r, blob, { contentType: mime });
          const url = await getDownloadURL(r);
          await push(ref(db, `chats/${matchId}/messages`), { from: me.id, type:'audio', url, ts: serverTimestamp() });
        }catch(err){ alert('Audio upload failed.'); }
        $('#send-voice').textContent = 'üéôÔ∏è Voice';
      };
      memoRec.start(100);
      $('#send-voice').textContent = '‚èπÔ∏è Stop';
    }catch(e){ alert('Mic permission needed.'); }
  }else{
    memoRec.stop();
  }
});

/* ===== Mutual-like auto-open ===== */
onValue(ref(db, `likes/${me.id}`), async (snap)=>{
  const mine = snap.val()||{};
  for (const otherId of Object.keys(mine)){
    const back = await get(ref(db, `likes/${otherId}/${me.id}`));
    if (back.exists()){
      const a = [me.id, otherId].sort(); matchId = `${a[0]}_${a[1]}`;
      const partnerSnap = await get(ref(db, `users/${otherId}`));
      const partner = partnerSnap.val() || {name:'Match', uid:otherId};
      openChat({uid:otherId, name:partner.name}); break;
    }
  }
});
</script>
</body>
</html>