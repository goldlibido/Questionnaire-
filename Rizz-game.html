<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Rizzler: Drop Your Best Line</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body{font-family:'Montserrat',sans-serif;background:#000;color:#fff;text-align:center;padding:20px;margin:0;overflow:hidden}
    .container{max-width:600px;margin:0 auto;border:2px solid #e1bf78;border-radius:15px;padding:20px;box-shadow:0 0 20px #e1bf78}
    h1{font-size:2em;color:#e1bf78;margin-bottom:10px;text-shadow:0 0 10px #e1bf78}
    h1 span{color:#e1bf78;animation:pulse 2s infinite}
    button{padding:15px 30px;margin:10px;font-size:1.2em;border:none;border-radius:25px;cursor:pointer;transition:transform .2s,box-shadow .2s;color:#fff}
    button:hover{transform:scale(1.1);box-shadow:0 0 15px currentColor}
    #speak-btn{background:#06954E}
    #listen-btn{background:#064D95}
    #accept-btn,#send-btn{background:#950606}
    #next-btn{background:#950606}
    #profile-form,#listen-section,#match-section{margin-top:20px}
    input{padding:10px;margin:5px;border:1px solid #e1bf78;border-radius:10px;background:#222;color:#fff;font-family:'Montserrat',sans-serif}
    #audio-player{margin:20px auto;width:100%}
    #chat-window{height:200px;overflow-y:auto;border:1px solid #e1bf78;border-radius:10px;padding:10px;background:#111;margin-bottom:10px;text-align:left}
    .chat-message{padding:8px;margin:5px 0;border-radius:15px;max-width:80%;word-wrap:break-word;animation:slideIn .3s ease-out}
    .sent{background:#06954E;margin-left:auto}
    .received{background:#064D95;margin-right:auto}
    .hidden{display:none}
    @keyframes pulse{0%{opacity:1}50%{opacity:.6}100%{opacity:1}}
    @keyframes slideIn{from{transform:translateY(20px);opacity:0}to{transform:translateY(0);opacity:1}}
    body::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle,rgba(225,191,120,.1) 0%,rgba(0,0,0,0) 100%);z-index:-1}
  </style>
</head>
<body>
  <div class="container">
    <h1>Rizzler: Unleash Your <span>Rizz!</span></h1>

    <div id="profile-form">
      <input type="text" id="username" placeholder="Your name (required)" required>
      <input type="text" id="photo-url" placeholder="Photo URL (optional)">
      <button id="enter-btn">Enter the Game</button>
    </div>

    <div id="main-section" class="hidden">
      <button id="speak-btn">Speak Your Line</button>
      <button id="listen-btn">Listen & Rizz</button>
    </div>

    <div id="listen-section" class="hidden">
      <audio id="audio-player" controls crossorigin="anonymous"></audio>
      <button id="accept-btn">Accept & Match</button>
      <button id="next-btn">Next Line</button>
    </div>

    <div id="match-section" class="hidden">
      <h2>Match! Let the Sparks Fly!</h2>
      <p id="match-info"></p>
      <div id="chat-window"></div>
      <input type="text" id="chat-input" placeholder="Type your flirty message...">
      <button id="send-btn">Send</button>
    </div>
  </div>

  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script>
    let peer, conn;
    let mediaRecorder, recordingStream;
    let audioChunks = [];
    let userProfile = {};
    let currentPeerId = null;
    let matched = false;

    // Receiver-side reassembly buffers
    let incomingChunks = [];
    let incomingMime = 'audio/webm;codecs=opus';
    let incomingSize = 0;

    // --- Helpers ---
    function getSupportedMime() {
      const tryTypes = [
        'audio/webm;codecs=opus',
        'audio/webm',
        'audio/mp4',           // iOS Safari often supports this
        'audio/ogg;codecs=opus'
      ];
      for (const t of tryTypes) {
        if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) {
          return t;
        }
      }
      // Fallback to whatever the browser gives
      return '';
    }

    function ensureConnectionForSending() {
      if (conn && conn.open) return true;
      if (!currentPeerId) {
        currentPeerId = prompt('Enter the Peer ID to send your line to:');
        if (!currentPeerId) return false;
      }
      conn = peer.connect(currentPeerId);
      conn.on('data', handleData);
      conn.on('open', () => {
        // Send my profile when we connect
        conn.send({ type: 'profile', data: userProfile });
      });
      conn.on('close', () => console.log('Connection closed'));
      conn.on('error', (e) => console.error('Conn error:', e));
      return true;
    }

    function playBlobInAudio(blob) {
      const audio = document.getElementById('audio-player');
      const url = URL.createObjectURL(blob);
      audio.srcObject = null;
      audio.src = url;
      audio.load();
      // Autoplay may be blocked; the user can tap play. Try anyway:
      audio.play().catch(() => {/* ignore autoplay block */});
    }

    // --- Peer setup ---
    function initPeer() {
      peer = new Peer();
      peer.on('open', (id) => {
        console.log('Your Peer ID:', id);
        alert('Share this Peer ID with others: ' + id);
      });
      peer.on('connection', (connection) => {
        conn = connection;
        conn.on('data', handleData);
        conn.on('open', () => {
          // Send my profile to the other side
          conn.send({ type: 'profile', data: userProfile });
        });
      });

      // Optional: live streaming path (not required for blob flow)
      peer.on('call', (call) => {
        // Answer without sending back a stream (receive-only)
        call.answer();
        call.on('stream', (remoteStream) => {
          const audio = document.getElementById('audio-player');
          audio.srcObject = remoteStream;
          audio.muted = false;
          audio.play().catch(e => console.error('Audio play error:', e));
        });
      });

      peer.on('error', (e) => console.error('Peer error:', e));
    }

    // --- Profile save / UI wiring ---
    document.getElementById('enter-btn').addEventListener('click', () => {
      userProfile.name = document.getElementById('username').value.trim();
      userProfile.photo = document.getElementById('photo-url').value.trim() || 'No photo';
      if (!userProfile.name) { alert('Name is required!'); return; }
      document.getElementById('profile-form').classList.add('hidden');
      document.getElementById('main-section').classList.remove('hidden');
      initPeer();
    });

    document.getElementById('speak-btn').addEventListener('click', () => {
      const btn = document.getElementById('speak-btn');
      if (btn.dataset.state === 'recording') {
        stopRecording();
      } else {
        startRecording();
      }
    });

    document.getElementById('listen-btn').addEventListener('click', startListening);
    document.getElementById('accept-btn').addEventListener('click', acceptLine);
    document.getElementById('next-btn').addEventListener('click', nextLine);
    document.getElementById('send-btn').addEventListener('click', sendMessage);

    // --- Recording flow (record → send blob over data channel) ---
    function startRecording() {
      // Make sure we know who to send to (or establish a connection)
      if (!ensureConnectionForSending()) return;

      navigator.mediaDevices.getUserMedia({ audio: true }).then((s) => {
        recordingStream = s;

        const mimeType = getSupportedMime();
        try {
          mediaRecorder = new MediaRecorder(recordingStream, mimeType ? { mimeType } : {});
        } catch (e) {
          alert('MediaRecorder failed to start: ' + e.message);
          return;
        }

        audioChunks = [];
        mediaRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) {
            audioChunks.push(e.data);
          }
        };
        mediaRecorder.onstop = async () => {
          // Stop mic
          recordingStream.getTracks().forEach(t => t.stop());

          // Build the final blob
          const finalMime = mediaRecorder.mimeType || mimeType || 'audio/webm';
          const blob = new Blob(audioChunks, { type: finalMime });

          // Immediately play locally for the speaker (optional)
          // playBlobInAudio(blob);

          // Send to peer in chunks so we don’t overflow the data channel
          sendBlobInChunks(blob, finalMime);

          // Reset UI
          const btn = document.getElementById('speak-btn');
          btn.innerText = 'Speak Your Line';
          btn.dataset.state = '';
        };

        mediaRecorder.start(100); // collect data every 100ms
        const btn = document.getElementById('speak-btn');
        btn.innerText = 'Stop Recording';
        btn.dataset.state = 'recording';
      }).catch((e) => {
        alert('Microphone access denied: ' + e.message);
      });
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
    }

    // Chunked send over data channel
    function sendBlobInChunks(blob, mimeType) {
      if (!conn || !conn.open) {
        alert('Not connected to a peer to send your line.');
        return;
      }
      // Announce start and mime
      conn.send({ type: 'audio-start', mime: mimeType, size: blob.size });

      const chunkSize = 16 * 1024; // 16KB
      const reader = new FileReader();
      let offset = 0;

      reader.onload = (e) => {
        const arr = new Uint8Array(e.target.result);
        conn.send({ type: 'audio-chunk', data: arr });
        offset += arr.length;

        if (offset < blob.size) {
          readNextChunk();
        } else {
          conn.send({ type: 'audio-end' });
          console.log('Audio sent.');
        }
      };

      function readNextChunk() {
        const slice = blob.slice(offset, offset + chunkSize);
        reader.readAsArrayBuffer(slice);
      }

      readNextChunk();
    }

    // --- Listening flow ---
    function startListening() {
      document.getElementById('main-section').classList.add('hidden');
      document.getElementById('listen-section').classList.remove('hidden');

      if (!peer) { initPeer(); }

      // For MVP, prompt for peer ID to pull from
      currentPeerId = prompt('Enter the Peer ID of someone to connect with:');
      if (currentPeerId) {
        conn = peer.connect(currentPeerId);
        conn.on('open', () => {
          conn.send({ type: 'profile', data: userProfile });
          console.log('Connection open');
        });
        conn.on('data', handleData);
        conn.on('close', () => console.log('Connection closed'));
        conn.on('error', (e) => console.error('Conn error:', e));
      }
    }

    // --- Data handler (profiles, messages, audio chunks, match) ---
    function handleData(msg) {
      if (!msg || !msg.type) return;

      switch (msg.type) {
        case 'profile':
          // Got the other side's profile; nothing to do yet
          break;

        case 'audio-start':
          incomingChunks = [];
          incomingMime = msg.mime || 'audio/webm;codecs=opus';
          incomingSize = msg.size || 0;
          break;

        case 'audio-chunk':
          // msg.data is Uint8Array
          incomingChunks.push(msg.data);
          break;

        case 'audio-end': {
          // Reassemble
          const blob = new Blob(incomingChunks, { type: incomingMime });
          // (Optional) sanity check size
          // console.log('Received bytes:', incomingChunks.reduce((a, b) => a + b.length, 0), 'expected:', incomingSize);
          playBlobInAudio(blob);
          break;
        }

        case 'accept':
          if (!matched) {
            matched = true;
            showMatch(msg.data);
          }
          break;

        case 'message':
          if (matched) {
            displayMessage(msg.data, false);
          }
          break;

        default:
          console.log('Unknown message type:', msg.type);
      }
    }

    // --- Match / Chat ---
    function acceptLine() {
      if (conn && conn.open) {
        matched = true;
        conn.send({ type: 'accept', data: userProfile });

        // Show other profile if we cached it; for MVP show mine if not sent yet
        showMatch(userProfile);
      }
    }

    function nextLine() {
      if (conn) try { conn.close(); } catch {}
      const audio = document.getElementById('audio-player');
      audio.srcObject = null;
      audio.src = '';
      startListening();
    }

    function showMatch(otherProfile) {
      document.getElementById('listen-section').classList.add('hidden');
      document.getElementById('match-section').classList.remove('hidden');
      const matchInfo = document.getElementById('match-info');
      matchInfo.innerHTML = `Matched with ${otherProfile.name}! ${
        otherProfile.photo !== 'No photo'
          ? `<br><img src="${otherProfile.photo}" alt="Profile Photo" style="max-width: 150px; border-radius: 50%; border: 2px solid #e1bf78;">`
          : ''
      }`;
    }

    function sendMessage() {
      const input = document.getElementById('chat-input');
      const message = input.value.trim();
      if (!message) return;
      if (conn && conn.open) {
        conn.send({ type: 'message', data: message });
        displayMessage(message, true);
        input.value = '';
      }
    }

    function displayMessage(message, isSent) {
      const chatWindow = document.getElementById('chat-window');
      const messageDiv = document.createElement('div');
      messageDiv.className = `chat-message ${isSent ? 'sent' : 'received'}`;
      messageDiv.textContent = message;
      chatWindow.appendChild(messageDiv);
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }
  </script>
</body>
</html>