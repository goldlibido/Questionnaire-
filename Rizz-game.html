<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rizzler ‚Äî Audio Swipe</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{--gold:#e1bf78;--blue:#064D95;--green:#06954E;--red:#c40018;--ink:#111;}
  *{box-sizing:border-box}
  body{margin:0;background:#000;color:#fff;font-family:'Montserrat',sans-serif}
  .wrap{max-width:840px;margin:0 auto;padding:16px}
  .card{border:2px solid var(--gold);border-radius:14px;background:#0b0b0b;box-shadow:0 0 18px rgba(225,191,120,.5);padding:14px;margin:10px 0}
  h1{margin:2px 0 10px;color:var(--gold);font-size:1.7rem;text-align:center}
  label{display:block;margin:8px 0 4px}
  input[type="text"]{width:100%;padding:10px;border:1px solid var(--gold);border-radius:10px;background:#1c1c1c;color:#fff}
  button{padding:12px 16px;border:none;border-radius:24px;color:#fff;background:#333;cursor:pointer;margin:6px 6px 0 0;font-size:1rem;transition:transform .15s,box-shadow .15s}
  button:hover{transform:scale(1.04);box-shadow:0 0 10px currentColor}
  .btn-green{background:var(--green)} .btn-blue{background:var(--blue)} .btn-red{background:var(--red)}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .center{display:flex;justify-content:center}
  audio{width:100%;background:#000;margin:6px 0}
  #status{min-height:1.3em;opacity:.95;margin-top:6px}
  #status.ok{color:#9bffa6} #status.err{color:#ff7b86}
  #browse-none{opacity:.85}
  #chat{max-height:360px;overflow-y:auto;border:1px solid var(--gold);border-radius:10px;background:var(--ink);padding:10px;margin-top:10px}
  .bubble{display:inline-block;max-width:78%; padding:8px 10px;margin:6px 0;border-radius:12px;animation:fade .2s ease-out}
  .me{background:var(--green);margin-left:auto} .them{background:var(--blue);margin-right:auto}
  .bubble img{max-width:220px;border-radius:10px;display:block}
  @keyframes fade{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}
  .muted{opacity:.7}
</style>
</head>
<body>
<div class="wrap">
  <h1>Rizzler ‚Äî Audio Swipe</h1>

  <!-- Onboarding -->
  <div class="card" id="onboard">
    <label>Your display name</label>
    <input id="name" type="text" placeholder="e.g., Venus" />
    <div class="row">
      <button id="go" class="btn-green">Start</button>
      <div id="status" class="muted">Say your best line, then browse others.</div>
    </div>
  </div>

  <!-- Record my line -->
  <div class="card" id="record" hidden>
    <strong>Record your pick-up line</strong>
    <div class="row">
      <button id="rec-btn" class="btn-green">üéôÔ∏è Start recording</button>
      <button id="submit-line" class="btn-blue" disabled>Upload line</button>
      <span id="rec-hint" class="muted">Tap to start, tap again to stop.</span>
    </div>
    <audio id="my-preview" controls hidden></audio>
  </div>

  <!-- Browse audio cards -->
  <div class="card" id="browse" hidden>
    <strong>Browse daters</strong>
    <audio id="card-audio" controls></audio>
    <div id="card-meta" class="muted"></div>
    <div class="row center">
      <button id="pass" class="btn-red">Pass</button>
      <button id="like" class="btn-green">Like</button>
      <button id="next" class="btn-blue">Next</button>
    </div>
    <div id="browse-none" class="center muted" hidden>No more lines right now ‚Äî try again in a bit.</div>
  </div>

  <!-- Match + chat -->
  <div class="card" id="chat-card" hidden>
    <strong id="chat-title">Match!</strong>
    <div id="chat"></div>
    <div class="row">
      <input id="msg" type="text" placeholder="Type a message‚Ä¶">
      <button id="send" class="btn-green">Send</button>

      <input id="photo" type="file" accept="image/*" hidden>
      <button id="send-photo" class="btn-blue">üì∑ Photo</button>

      <button id="send-voice" class="btn-blue">üéôÔ∏è Voice</button>
    </div>
  </div>
</div>

<script type="module">
/* ===== Firebase ===== */
import { db } from './firebase-config.js';
import {
  ref, push, set, get, update, remove, serverTimestamp,
  onChildAdded, onValue, query, orderByChild, limitToLast
} from "https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js";

/* ===== Helpers ===== */
const $ = s => document.querySelector(s);
const uid = () => (crypto.randomUUID? crypto.randomUUID(): Math.random().toString(36).slice(2));
const setStatus = (t, cls='') => { const el=$('#status'); el.textContent=t||''; el.className=cls; };
function b64FromBlob(blob){ return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result.split(',')[1]); r.onerror=rej; r.readAsDataURL(blob); }); }
function blobFromB64(b64, mime){ const bin = atob(b64); const len = bin.length; const arr = new Uint8Array(len); for(let i=0;i<len;i++) arr[i]=bin.charCodeAt(i); return new Blob([arr], {type:mime}); }
function ts(){ return Date.now(); }

/* ===== State ===== */
let me = { id: uid(), name: "" };
let myLine = null; // { mime, b64, dur }
let rec, recChunks=[], recStream=null;

let feed = []; let feedPos = -1;
let currentCard = null; // {userId, name, mime, b64, ts}
let matchId = null;

/* ===== Onboarding ===== */
$('#go').addEventListener('click', async ()=>{
  me.name = ($('#name').value||'').trim() || 'Rizzler';
  $('#onboard').hidden = true;
  $('#record').hidden = false;
  // create presence
  await update(ref(db, `users/${me.id}`), { name: me.name, active: true, ts: ts() });
});

/* ===== Recording my line ===== */
function bestMime(){
  const types = ['audio/webm;codecs=opus','audio/mp4','audio/webm','audio/ogg;codecs=opus'];
  for (const t of types) if (window.MediaRecorder?.isTypeSupported?.(t)) return t;
  return '';
}
$('#rec-btn').addEventListener('click', async ()=>{
  if (!rec || rec.state === 'inactive'){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({audio:true});
      recStream = stream;
      const mt = bestMime();
      recChunks = [];
      rec = new MediaRecorder(stream, mt?{mimeType:mt}:{});
      rec.ondataavailable = e=>{ if (e.data && e.data.size) recChunks.push(e.data); };
      rec.onstop = async ()=>{
        recStream.getTracks().forEach(t=>t.stop());
        const mime = rec.mimeType || mt || 'audio/webm';
        const blob = new Blob(recChunks, {type:mime});
        const url = URL.createObjectURL(blob);
        $('#my-preview').hidden = false;
        $('#my-preview').src = url;
        $('#submit-line').disabled = false;
        setStatus('Ready to upload your line.','ok');
      };
      rec.start(100);
      $('#rec-btn').textContent = '‚èπÔ∏è Stop';
      setStatus('Recording‚Ä¶');
    }catch(e){
      setStatus('Microphone blocked ‚Äî enable mic permissions.', 'err');
    }
  }else{
    rec.stop();
    $('#rec-btn').textContent = 'üéôÔ∏è Start recording';
  }
});

$('#submit-line').addEventListener('click', async ()=>{
  if (!recChunks.length){ setStatus('Record first.','err'); return; }
  const mime = $('#my-preview').src.includes('audio/mp4') ? 'audio/mp4' : (rec?.mimeType || bestMime() || 'audio/webm');
  const blob = new Blob(recChunks, {type:mime});
  const b64 = await b64FromBlob(blob);

  // (re)publish my line at /lines/{me.id}
  await set(ref(db, `lines/${me.id}`), {
    uid: me.id, name: me.name, mime, b64, ts: serverTimestamp()
  });

  myLine = { mime, b64 };
  $('#record').hidden = true;
  await loadFeed();
  $('#browse').hidden = false;
  setStatus('Line uploaded. Start browsing!','ok');
});

/* ===== Browse feed ===== */
async function loadFeed(){
  // pull latest 30 lines (excluding me)
  const snap = await get(query(ref(db,'lines'), orderByChild('ts'), limitToLast(30)));
  feed = [];
  snap.forEach(s=>{
    const v = s.val();
    if (v && v.uid !== me.id) feed.push(v);
  });
  // newest first
  feed.sort((a,b)=>(b.ts||0)-(a.ts||0));
  feedPos = -1;
  nextCard();
}
function nextCard(){
  $('#browse-none').hidden = true;
  for (let i=feedPos+1; i<feed.length; i++){
    const v = feed[i];
    currentCard = v;
    feedPos = i;
    renderCard(v);
    return;
  }
  currentCard = null;
  $('#card-audio').src = '';
  $('#card-meta').textContent = '';
  $('#browse-none').hidden = false;
}
function renderCard(v){
  const blob = blobFromB64(v.b64, v.mime||'audio/webm');
  const url  = URL.createObjectURL(blob);
  $('#card-audio').src = url;
  $('#card-meta').textContent = `${v.name||'Rizzler'} ‚Ä¢ tap play to listen`;
}

/* actions */
$('#next').addEventListener('click', nextCard);
$('#pass').addEventListener('click', async ()=>{
  if (!currentCard) return; // mark viewed (optional)
  await set(ref(db, `passes/${me.id}/${currentCard.uid}`), true);
  nextCard();
});
$('#like').addEventListener('click', async ()=>{
  if (!currentCard) return;
  // write my like
  await set(ref(db, `likes/${me.id}/${currentCard.uid}`), true);

  // check mutual
  const snap = await get(ref(db, `likes/${currentCard.uid}/${me.id}`));
  if (snap.exists()){
    // create match id & room
    const a = [me.id, currentCard.uid].sort();
    matchId = `${a[0]}_${a[1]}`;
    await update(ref(db, `matches/${matchId}`), {
      a: a[0], b: a[1], ts: serverTimestamp()
    });
    // small notifications (optional)
    await set(ref(db, `notifs/${currentCard.uid}/${matchId}`), {ts: serverTimestamp(), from: me.id});

    openChat(currentCard);
  }else{
    setStatus('Like sent ‚Äî if they like you back, you‚Äôll match!','ok');
    nextCard();
  }
});

/* ===== Chat ===== */
let chatUnsub = null;
function openChat(partner){
  $('#browse').hidden = true;
  $('#chat-card').hidden = false;
  $('#chat-title').textContent = `Chat with ${partner.name||'Match'}`;
  $('#chat').innerHTML = '';

  // live stream messages
  if (chatUnsub) chatUnsub();
  const msgsRef = ref(db, `chats/${matchId}/messages`);
  chatUnsub = onChildAdded(msgsRef, (snap)=>{
    const m = snap.val(); renderMsg(m);
  });
}

function renderMsg(m){
  const box = $('#chat');
  const b = document.createElement('div');
  b.className = 'bubble ' + (m.from===me.id ? 'me':'them');

  if (m.type==='text'){
    b.textContent = m.text;
  } else if (m.type==='image'){
    const img = document.createElement('img');
    img.src = URL.createObjectURL(blobFromB64(m.b64, m.mime||'image/jpeg'));
    b.appendChild(img);
  } else if (m.type==='audio'){
    const a = document.createElement('audio');
    a.controls = true;
    a.src = URL.createObjectURL(blobFromB64(m.b64, m.mime||'audio/webm'));
    b.appendChild(a);
  }
  box.appendChild(b);
  box.scrollTop = box.scrollHeight;
}

/* send text */
$('#send').addEventListener('click', async ()=>{
  const t = ($('#msg').value||'').trim();
  if (!t || !matchId) return;
  await push(ref(db, `chats/${matchId}/messages`), {
    from: me.id, type:'text', text:t, ts: serverTimestamp()
  });
  $('#msg').value = '';
});

/* send photo */
$('#send-photo').addEventListener('click', ()=> $('#photo').click());
$('#photo').addEventListener('change', async (e)=>{
  const f = e.target.files?.[0]; if (!f || !matchId) return;
  const array = await f.arrayBuffer();
  const b64 = btoa(String.fromCharCode(...new Uint8Array(array)));
  await push(ref(db, `chats/${matchId}/messages`), {
    from: me.id, type:'image', mime: f.type||'image/jpeg', b64, ts: serverTimestamp()
  });
  e.target.value = '';
});

/* send voice memo */
let memoRec=null, memoChunks=[], memoStream=null;
$('#send-voice').addEventListener('click', async ()=>{
  if (!matchId) return;
  if (!memoRec || memoRec.state==='inactive'){
    try{
      const s = await navigator.mediaDevices.getUserMedia({audio:true});
      memoStream = s;
      memoChunks = [];
      const mt = bestMime();
      memoRec = new MediaRecorder(s, mt?{mimeType:mt}:{});
      memoRec.ondataavailable = e=>{ if (e.data && e.data.size) memoChunks.push(e.data); };
      memoRec.onstop = async ()=>{
        memoStream.getTracks().forEach(t=>t.stop());
        const mime = memoRec.mimeType || mt || 'audio/webm';
        const blob = new Blob(memoChunks, {type:mime});
        const b64 = await b64FromBlob(blob);
        await push(ref(db, `chats/${matchId}/messages`), {
          from: me.id, type:'audio', mime, b64, ts: serverTimestamp()
        });
        $('#send-voice').textContent = 'üéôÔ∏è Voice';
      };
      memoRec.start(100);
      $('#send-voice').textContent = '‚èπÔ∏è Stop';
    }catch(e){
      alert('Mic permission needed for voice memos.');
    }
  }else{
    memoRec.stop();
  }
});

/* ===== Live updates: if someone likes me and we liked them earlier ‚Üí open chat ===== */
onValue(ref(db, `likes/${me.id}`), async (snap)=>{
  const mine = snap.val()||{};
  // check mutuals: if someone liked me and I already liked them, open chat
  for (const otherId of Object.keys(mine)){
    const back = await get(ref(db, `likes/${otherId}/${me.id}`));
    if (back.exists()){
      const a = [me.id, otherId].sort();
      matchId = `${a[0]}_${a[1]}`;
      const partnerSnap = await get(ref(db, `users/${otherId}`));
      const partner = partnerSnap.val() || {name:'Match', uid:otherId};
      openChat({uid:otherId, name:partner.name});
      break;
    }
  }
});
</script>
</body>
</html>
