<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Rizzler</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{--gold:#e1bf78;--blue:#064D95;--green:#06954E;--red:#c40018;--redBright:#ff1e2d;}
  body{font-family:'Montserrat',sans-serif;background:#000;color:#fff;text-align:center;padding:20px;margin:0}
  .container{max-width:680px;margin:0 auto;border:2px solid var(--gold);border-radius:14px;padding:18px;box-shadow:0 0 18px var(--gold)}
  h1{font-size:1.9em;color:var(--gold);margin:0 0 10px}
  .pulse{color:var(--redBright);display:inline-block;animation:pulse 1.4s ease-in-out infinite}
  @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.15)}100%{transform:scale(1)}}
  button{padding:12px 22px;margin:8px;font-size:1.05em;border:none;border-radius:24px;cursor:pointer;transition:transform .2s,box-shadow .2s;color:#fff}
  button:hover{transform:scale(1.05);box-shadow:0 0 10px currentColor}
  #speak-btn{background:var(--green)}
  #listen-btn{background:var(--blue)}
  #accept-btn{background:var(--red)}
  #send-btn,#audio-send-btn{background:var(--green)}
  #photo-btn{background:var(--blue)}
  input[type="text"]{padding:10px;margin:5px;border:1px solid var(--gold);border-radius:10px;background:#222;color:#fff}
  .hidden{display:none}
  #status{opacity:.95;min-height:1.4em;margin:6px 0 10px}
  #audio-player{margin:12px auto;width:100%}
  #chat-window{height:260px;overflow-y:auto;border:1px solid var(--gold);border-radius:10px;padding:10px;background:#111;margin-bottom:10px;text-align:left}
  .chat-message{padding:8px 10px;margin:6px 0;border-radius:12px;max-width:85%;word-wrap:break-word;animation:slideIn .25s ease-out;display:inline-block}
  .sent{background:var(--green);margin-left:auto}
  .received{background:var(--blue);margin-right:auto}
  @keyframes slideIn{from{transform:translateY(12px);opacity:0}to{transform:translateY(0);opacity:1}}
  .row{display:flex;gap:8px;justify-content:center;align-items:center;flex-wrap:wrap}
  .tiny{font-size:.9em;opacity:.85}
</style>
</head>
<body>
<div class="container">
  <h1>Unleash Your <span class="pulse">Rizz</span></h1>

  <div id="status">Initializing‚Ä¶</div>

  <!-- Main actions -->
  <div id="main">
    <button id="speak-btn">Speak & Rizz</button>
    <button id="listen-btn">Listen & Get Rizzed</button>
  </div>

  <!-- Speak flow -->
  <div id="speak-section" class="hidden">
    <p><strong>Record your line:</strong></p>
    <button id="record-toggle">Start Recording</button>
    <div class="tiny">Tap once to start; tap again to stop & send.</div>
  </div>

  <!-- Listen flow -->
  <div id="listen-section" class="hidden">
    <audio id="audio-player" controls crossorigin="anonymous" playsinline></audio><br>
    <button id="accept-btn" class="hidden">Accept & Match</button>
    <div class="tiny">Your match‚Äôs line will play here.</div>
  </div>

  <!-- Match / Chat -->
  <div id="match-section" class="hidden">
    <h2>Chat</h2>
    <div id="chat-window"></div>
    <div class="row">
      <input type="text" id="chat-input" placeholder="Type your message‚Ä¶" style="flex:1;min-width:180px">
      <button id="send-btn">Send</button>
      <input id="photo-input" class="hidden" type="file" accept="image/*" capture="environment">
      <button id="photo-btn" title="Send photo">üì∑</button>
      <button id="audio-send-btn" title="Record/send audio">üéôÔ∏è</button>
    </div>
  </div>
</div>

<!-- PeerJS -->
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

<!-- App -->
<script type="module">
/* ================== dynamic Firebase load (safe if file missing) ================== */
let db=null;
let rtdb={};
async function loadFirebase(){
  try{
    const cfg = await import('./firebase-config.js');   // your file, exports { db }
    db = cfg.db;
    rtdb = await import('https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js');
    return true;
  }catch(e){
    console.error('Firebase load failed:', e);
    return false;
  }
}

/* ================== UI helpers ================== */
const $ = s => document.querySelector(s);
const setStatus = s => $('#status').textContent = s || '';

const CHUNK_SIZE = 16*1024;

/* ================== iOS-friendly MIME ================== */
function getSupportedMime(){
  const types = ['audio/mp4','audio/webm;codecs=opus','audio/webm','audio/ogg;codecs=opus'];
  for (const t of types){ if (window.MediaRecorder?.isTypeSupported?.(t)) return t; }
  return '';
}

/* ================== PeerJS setup ================== */
let peer, conn, myPeerId=null, partnerId=null;

function initPeer(){
  return new Promise(resolve=>{
    peer = new Peer(undefined,{
      debug:2,
      config:{ iceServers:[
        {urls:'stun:stun.l.google.com:19302'},
        {urls:'stun:stun1.l.google.com:19302'},
        {urls:'stun:stun2.l.google.com:19302'}
      ]}
    });
    peer.on('open', id => { myPeerId=id; resolve(); });
    peer.on('connection', c => establishConn(c));
    peer.on('call', c => { try{c.close();}catch{} }); // data-channel only
    peer.on('disconnected', ()=>{ try{peer.reconnect();}catch{} });
    peer.on('error', e => console.error('Peer error:', e));
  });
}

function establishConn(c){
  if (conn && conn.open && c.peer !== conn.peer){ try{c.close();}catch{}; return; }
  conn = c;
  conn.on('open', () => {
    setStatus('Matched! Choose Speak or Listen.');
    $('#main').classList.remove('hidden');
  });
  conn.on('data', handleData);
  conn.on('close', onDisconnect);
  conn.on('error', onDisconnect);
}

function onDisconnect(){
  setStatus('Partner disconnected. Finding you a new match‚Ä¶');
  conn = null; partnerId=null;
  $('#speak-section').classList.add('hidden');
  $('#listen-section').classList.add('hidden');
  $('#match-section').classList.add('hidden');
  $('#main').classList.remove('hidden');
  if (db) joinQueue(); // requeue
}

/* ================== Firebase matchmaking (no IDs, auto-join) ================== */
const QUEUE_TTL_MS = 30000;
const CLAIM_BATCH  = 8;
let myTicketRef=null, myPairRef=null, requeueTimer=null;

function isFresh(ts){ return !ts || (Date.now()-ts)<QUEUE_TTL_MS; }
function safeRemove(r){ try{ r && rtdb.remove(r); }catch{} }

function joinQueue(){
  const { ref, push, set, onValue, onDisconnect, remove, update, get,
          runTransaction, serverTimestamp, query, orderByChild, equalTo,
          limitToFirst, endAt } = rtdb;

  setStatus('Finding a random match‚Ä¶');
  myTicketRef = push(ref(db,'queue'));
  set(myTicketRef,{ peer: myPeerId, claimed:false, ts: serverTimestamp() });
  onDisconnect(myTicketRef).remove();

  myPairRef = ref(db,'pairs/'+myPeerId);
  onDisconnect(myPairRef).remove();
  onValue(myPairRef, snap=>{
    const v = snap.val();
    if (v?.partner && !partnerId){
      partnerId = v.partner;
      clearTimeout(requeueTimer);
      maybeInitiateConnection();
    }
  });

  cleanupStale(()=> importCandidatesAndClaim());

  requeueTimer = setTimeout(()=>{
    if (!partnerId){
      setStatus('Still looking‚Ä¶ re-queuing.');
      safeRemove(myTicketRef); safeRemove(myPairRef);
      joinQueue();
    }
  }, QUEUE_TTL_MS);

  function cleanupStale(done){
    const cutoff = Date.now() - QUEUE_TTL_MS;
    const q = query(ref(db,'queue'), orderByChild('ts'), endAt(cutoff), limitToFirst(25));
    get(q).then(snap=>{
      const updates = {};
      snap.forEach(cs=>{
        const v = cs.val();
        if (v && v.ts && v.ts<cutoff) updates[`queue/${cs.key}`] = null;
      });
      if (Object.keys(updates).length) update(ref(db),updates).finally(()=>done&&done());
      else done&&done();
    });
  }

  function importCandidatesAndClaim(){
    const q = query(ref(db,'queue'), orderByChild('claimed'), equalTo(false), limitToFirst(CLAIM_BATCH));
    get(q).then(snap=>{
      const cands = [];
      snap.forEach(cs=>{
        const v = cs.val();
        if (v && v.peer && v.peer!==myPeerId && isFresh(v.ts)) cands.push({key:cs.key, peer:v.peer, ts:v.ts});
      });
      tryClaim(cands,0);
    });
  }

  function tryClaim(list,i){
    if (partnerId || i>=list.length){ setStatus('Waiting for someone‚Ä¶'); return; }
    const cand = list[i];
    const claimPath = rtdb.ref(db,`queue/${cand.key}/claimed`);
    runTransaction(claimPath, cur => cur===false ? myPeerId : cur)
      .then(res=>{
        if (res.committed && res.snapshot.val()===myPeerId){
          const updates = {};
          updates[`pairs/${myPeerId}`] = {partner:cand.peer, ts:Date.now()};
          updates[`pairs/${cand.peer}`] = {partner:myPeerId, ts:Date.now()};
          updates[`queue/${myTicketRef.key}`] = null;
          updates[`queue/${cand.key}`] = null;
          rtdb.update(rtdb.ref(db), updates).then(()=>{
            partnerId = cand.peer; clearTimeout(requeueTimer); maybeInitiateConnection();
          });
        } else {
          tryClaim(list,i+1);
        }
      })
      .catch(()=> tryClaim(list,i+1));
  }
}

function maybeInitiateConnection(){
  if (!partnerId || !myPeerId) return;
  if (conn && conn.open) return;
  if (myPeerId < partnerId){
    establishConn(peer.connect(partnerId, {reliable:true}));
  }
  // else: wait for inbound connection
}

/* ================== Recording / sending first line ================== */
let mediaRecorder=null, recordingStream=null, audioChunks=[];
let incomingChunks=[], incomingMime='audio/webm;codecs=opus';

$('#speak-btn').addEventListener('click', ()=>{
  if (!conn || !conn.open){ setStatus('Connecting you to a match‚Ä¶'); return; }
  $('#listen-section').classList.add('hidden');
  $('#speak-section').classList.remove('hidden');
});

$('#record-toggle').addEventListener('click', ()=>{
  // START
  if (!mediaRecorder || mediaRecorder.state!=='recording'){
    navigator.mediaDevices.getUserMedia({audio:true}).then(s=>{
      recordingStream=s;
      const mt = getSupportedMime();
      try{ mediaRecorder=new MediaRecorder(s, mt?{mimeType:mt}:{}) }catch(e){ alert('Recorder failed: '+e.message); return; }
      audioChunks=[];
      mediaRecorder.ondataavailable = e=>{ if (e.data && e.data.size>0) audioChunks.push(e.data); };
      mediaRecorder.onstop = ()=>{
        recordingStream.getTracks().forEach(t=>t.stop());
        const finalMime = mediaRecorder.mimeType || mt || 'audio/webm';
        const blob = new Blob(audioChunks,{type:finalMime});
        sendAudioBlob(blob, finalMime);
        $('#record-toggle').textContent='Start Recording';
        setStatus('Line sent!');
      };
      mediaRecorder.start(100);
      $('#record-toggle').textContent='Stop Recording';
      setStatus('Recording‚Ä¶');
    }).catch(e=> alert('Microphone access denied: '+e.message));
  }else{
    // STOP
    mediaRecorder.stop();
  }
});

/* ================== Listen flow ================== */
$('#listen-btn').addEventListener('click', ()=>{
  if (!conn || !conn.open){ setStatus('Connecting you to a match‚Ä¶'); return; }
  $('#speak-section').classList.add('hidden');
  $('#listen-section').classList.remove('hidden');
  // iOS autoplay priming
  const a=$('#audio-player'); a.muted=false; a.play().catch(()=>{});
  setStatus('Listening‚Ä¶');
});
function playBlobInAudio(blob){
  const a=$('#audio-player');
  const url = URL.createObjectURL(blob);
  a.srcObject=null; a.src=url; a.load();
  a.play().catch(()=>{});
}

/* ================== Accept ‚Üí open chat ================== */
$('#accept-btn').addEventListener('click', ()=>{
  if (!conn||!conn.open) return;
  conn.send({type:'accept'});
  openChat();
});
function openChat(){
  $('#listen-section').classList.add('hidden');
  $('#speak-section').classList.add('hidden');
  $('#match-section').classList.remove('hidden');
}

/* ================== Chat (text, photos, audio) ================== */
$('#send-btn').addEventListener('click', ()=>{
  const input=$('#chat-input'); const msg=input.value.trim();
  if (!msg || !(conn&&conn.open)) return;
  conn.send({type:'message', data: msg});
  appendMsg(msg,true);
  input.value='';
});
$('#photo-btn').addEventListener('click', ()=> $('#photo-input').click());
$('#photo-input').addEventListener('change', e=>{
  const f=e.target.files?.[0]; if (!f || !(conn&&conn.open)) return;
  f.arrayBuffer().then(buf=>{
    const b=new Blob([buf],{type:f.type||'image/jpeg'});
    appendImg(b,true); sendImg(b, f.name||'photo.jpg'); e.target.value='';
  });
});

/* audio messages in chat (toggle) */
let chatRecorder=null, chatStream=null, chatChunks=[];
$('#audio-send-btn').addEventListener('click', ()=>{
  if (!chatRecorder || chatRecorder.state!=='recording'){
    navigator.mediaDevices.getUserMedia({audio:true}).then(s=>{
      chatStream=s;
      const mt=getSupportedMime();
      try{ chatRecorder=new MediaRecorder(s, mt?{mimeType:mt}:{}) }catch(e){ alert('Recorder failed: '+e.message); return; }
      chatChunks=[];
      chatRecorder.ondataavailable=e=>{ if (e.data && e.data.size>0) chatChunks.push(e.data); };
      chatRecorder.onstop=()=>{
        chatStream.getTracks().forEach(t=>t.stop());
        const finalMime = chatRecorder.mimeType || mt || 'audio/webm';
        const blob=new Blob(chatChunks,{type:finalMime});
        sendChatAudioBlob(blob, finalMime);
        $('#audio-send-btn').textContent='üéôÔ∏è';
      };
      chatRecorder.start(100);
      $('#audio-send-btn').textContent='‚èπÔ∏è';
      setStatus('Recording audio message‚Ä¶');
    }).catch(e=> alert('Mic blocked: '+e.message));
  }else{
    chatRecorder.stop();
  }
});

/* ============ Chunked send helpers ============ */
function sendAudioBlob(blob, mimeType){
  if (!(conn&&conn.open)){ alert('Not connected to a partner yet.'); return; }
  conn.send({type:'audio-start', mime:mimeType, size:blob.size});
  const r=new FileReader(); let o=0;
  r.onload=e=>{
    conn.send({type:'audio-chunk', data:new Uint8Array(e.target.result)});
    o+=e.target.result.byteLength;
    if (o<blob.size) read(); else conn.send({type:'audio-end'});
  };
  function read(){ r.readAsArrayBuffer(blob.slice(o, o+CHUNK_SIZE)); }
  read();
}
function sendChatAudioBlob(blob,mimeType){
  if (!(conn&&conn.open)) return;
  conn.send({type:'chat-audio-start', mime:mimeType, size:blob.size});
  const r=new FileReader(); let o=0;
  r.onload=e=>{
    conn.send({type:'chat-audio-chunk', data:new Uint8Array(e.target.result)});
    o+=e.target.result.byteLength;
    if (o<blob.size) read(); else conn.send({type:'chat-audio-end'});
  };
  function read(){ r.readAsArrayBuffer(blob.slice(o, o+CHUNK_SIZE)); }
  read();
}
function sendImg(blob,name){
  if (!(conn&&conn.open)) return;
  conn.send({type:'image-start', mime:blob.type, name, size:blob.size});
  const r=new FileReader(); let o=0;
  r.onload=e=>{
    conn.send({type:'image-chunk', data:new Uint8Array(e.target.result)});
    o+=e.target.result.byteLength;
    if (o<blob.size) read(); else conn.send({type:'image-end'});
  };
  function read(){ r.readAsArrayBuffer(blob.slice(o, o+CHUNK_SIZE)); }
  read();
}

/* ============ Incoming data handler ============ */
let rxChat={parts:[],mime:'audio/webm;codecs=opus'};
let rxImage={parts:[],mime:'image/jpeg',name:'photo.jpg'};

function handleData(msg){
  if (!msg || !msg.type) return;
  switch(msg.type){
    /* first line audio */
    case 'audio-start':
      incomingChunks=[]; incomingMime=msg.mime||'audio/webm;codecs=opus';
      $('#listen-section').classList.remove('hidden');
      setStatus('Receiving a line‚Ä¶'); break;
    case 'audio-chunk':
      incomingChunks.push(msg.data); break;
    case 'audio-end': {
      const blob=new Blob(incomingChunks,{type:incomingMime});
      playBlobInAudio(blob);
      $('#accept-btn').classList.remove('hidden');
      setStatus('Line received!');
      break;
    }

    /* accept ‚Üí open chat */
    case 'accept': openChat(); break;

    /* text chat */
    case 'message': appendMsg(msg.data,false); break;

    /* chat audio */
    case 'chat-audio-start': rxChat={parts:[],mime:msg.mime||'audio/webm;codecs=opus'}; break;
    case 'chat-audio-chunk': rxChat.parts.push(msg.data); break;
    case 'chat-audio-end': {
      const blob=new Blob(rxChat.parts,{type:rxChat.mime});
      appendAudio(blob,false); rxChat={parts:[],mime:'audio/webm;codecs=opus'};
      break;
    }

    /* images */
    case 'image-start': rxImage={parts:[],mime:msg.mime||'image/jpeg',name:msg.name||'photo.jpg'}; break;
    case 'image-chunk': rxImage.parts.push(msg.data); break;
    case 'image-end': {
      const blob=new Blob(rxImage.parts,{type:rxImage.mime});
      appendImg(blob,false); rxImage={parts:[],mime:'image/jpeg',name:'photo.jpg'};
      break;
    }
  }
}

/* ============ Chat UI helpers ============ */
function appendMsg(m, sent){
  const box=$('#chat-window');
  const d=document.createElement('div');
  d.className='chat-message '+(sent?'sent':'received');
  d.textContent=m; box.appendChild(d); box.scrollTop=box.scrollHeight;
}
function appendImg(b, sent){
  const box=$('#chat-window');
  const d=document.createElement('div');
  d.className='chat-message '+(sent?'sent':'received');
  const i=document.createElement('img');
  i.src=URL.createObjectURL(b); i.style.maxWidth='220px'; i.style.borderRadius='10px'; i.style.display='block';
  d.appendChild(i); box.appendChild(d); box.scrollTop=box.scrollHeight;
}
function appendAudio(b, sent){
  const box=$('#chat-window');
  const d=document.createElement('div');
  d.className='chat-message '+(sent?'sent':'received');
  const a=document.createElement('audio');
  a.controls=true; a.src=URL.createObjectURL(b); a.preload='metadata'; a.style.display='block';
  d.appendChild(a); box.appendChild(d); box.scrollTop=box.scrollHeight;
}

/* ================== Boot ================== */
(async ()=>{
  $('#main').classList.add('hidden'); // hide until ready
  const firebaseOK = await loadFirebase();
  await initPeer();
  $('#main').classList.remove('hidden');
  if (firebaseOK){ joinQueue(); }
  else { setStatus('Firebase missing ‚Äî please ensure firebase-config.js is present.'); }
})();
</script>
</body>
</html>