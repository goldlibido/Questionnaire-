<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Le Libido — Audio Pickup Editor</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700;800&display=swap" rel="stylesheet">
<style>
  :root{ --gold:#e1bf78; --blue:#064D95; --green:#06954E; --red:#950606; --bg:#0d0d0d; --card:#151515; --muted:#b9b9b9; }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:var(--bg);font-family:Montserrat,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:#fff}
  .border-wrap{min-height:100vh;padding:2px;background:linear-gradient(100deg,var(--red),var(--blue),var(--green))}
  .app{min-height:calc(100vh - 4px);background:var(--bg);display:flex;flex-direction:column;align-items:center}
  header{width:100%;padding:22px 16px 8px;text-align:center}
  header img{width:120px;height:auto;display:block;margin:0 auto 10px;filter:drop-shadow(0 0 10px rgba(225,191,120,.25))}
  .title{font-weight:800;letter-spacing:.5px;font-size:clamp(20px,3vw,28px);text-shadow:0 0 8px rgba(225,191,120,.25)}
  .steps{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;padding:6px 16px 14px;width:100%}
  .step-pill{padding:8px 12px;border:1px solid rgba(225,191,120,.3);border-radius:999px;color:#fff;font-weight:600;font-size:12px;opacity:.6;user-select:none}
  .step-pill.active{opacity:1;border-color:var(--gold);box-shadow:0 0 14px rgba(225,191,120,.2) inset}
  .panel{width:min(1100px,94vw);background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:18px;margin:10px auto 28px;box-shadow:0 25px 60px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.02)}
  .panel h2{margin:6px 8px 14px;font-size:18px;font-weight:800;letter-spacing:.3px}
  .grid{display:grid;gap:14px} .grid.cols-2{grid-template-columns:1fr 1fr} @media (max-width:800px){.grid.cols-2{grid-template-columns:1fr}}
  .btn{appearance:none;border:0;border-radius:12px;padding:14px 18px;background:linear-gradient(180deg,#1e1e1e,#121212);color:#fff;font-weight:700;letter-spacing:.3px;cursor:pointer;border:1px solid rgba(255,255,255,.08);transition:.2s transform,.2s box-shadow,.2s background}
  .btn:hover{transform:translateY(-1px);box-shadow:0 8px 24px rgba(0,0,0,.35)}
  .btn.gold{background:linear-gradient(180deg,#f4d796,#c9a760);color:#111;border:1px solid #d7b56f;text-shadow:0 1px 0 rgba(255,255,255,.35)}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,.18)}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center} .hidden{display:none !important}
  label{font-size:12px;color:#e5e5e5;margin-bottom:6px;display:block}
  input[type="text"],select{width:100%;padding:12px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:#111;color:#fff;outline:none;font-size:14px;touch-action:manipulation}
  .rec-wrap{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.01));border:1px dashed rgba(255,255,255,.15);border-radius:14px;padding:16px}
  .record-btn{width:160px;height:160px;border-radius:999px;border:1px solid rgba(255,255,255,.15);cursor:pointer;background:radial-gradient(closest-side, rgba(225,191,120,.25) 0%, rgba(225,191,120,0) 78%),linear-gradient(180deg,#272727,#161616);color:#fff;font-weight:800;font-size:15px;letter-spacing:.5px;box-shadow:0 20px 60px rgba(0,0,0,.45),0 0 0 6px rgba(225,191,120,.08) inset}
  .rec-indicator{width:10px;height:10px;background:#f34a4a;border-radius:50%;box-shadow:0 0 12px rgba(243,74,74,.9);display:inline-block;margin-right:8px;vertical-align:middle;animation:pulse 1s infinite}
  @keyframes pulse{0%{transform:scale(1);opacity:1}50%{transform:scale(1.3);opacity:.65}100%{transform:scale(1);opacity:1}}
  .player{display:flex;align-items:center;gap:12px;margin-top:14px}
  .play-toggle{width:46px;height:46px;border-radius:50%;border:1px solid rgba(255,255,255,.15);background:#151515;color:#fff;font-weight:800;cursor:pointer}
  .bar{flex:1;height:10px;background:#0f0f0f;border-radius:999px;position:relative;border:1px solid rgba(255,255,255,.1);overflow:hidden;cursor:pointer}
  .bar .fill{position:absolute;inset:0 100% 0 0;background:linear-gradient(90deg,var(--red),var(--blue),var(--green));border-right:2px solid rgba(255,255,255,.5)}
  .time{font-size:12px;color:var(--muted);width:74px;text-align:right}
  .editor-wrap{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.01));border:1px dashed rgba(255,255,255,.15);border-radius:14px;padding:16px;margin-top:16px}
  .timeline{position:relative;height:120px;background:#0f0f0f;border:1px solid rgba(255,255,255,.1);border-radius:8px;overflow:hidden}
  .timeline canvas{width:100%;height:100%;}
  .segments-container{position:absolute;top:0;left:0;width:100%;height:100%;overflow:hidden;}
  .segment{position:absolute;height:100%;background:rgba(225,191,120,.2);border:1px solid var(--gold);cursor:move;opacity:0.7;}
  .segment:hover{opacity:1;}
  .effects{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  .effect-btn{padding:6px 10px;border-radius:999px;background:#151515;border:1px solid rgba(255,255,255,.15);cursor:pointer;font-size:12px;color:#fff}
  .effect-item{padding:6px;border-radius:8px;background:rgba(0,0,0,.5);cursor:grab;border:1px solid rgba(255,255,255,.2);margin:5px;}
  .deck{position:relative;height:420px;border-radius:16px;overflow:hidden;background:#0f0f10;border:1px solid rgba(255,255,255,.08)}
  .card{position:absolute;inset:0;padding:18px;display:flex;flex-direction:column;justify-content:flex-end;background:radial-gradient(1200px 500px at 100% -10%, rgba(255,255,255,.06), transparent 70%),linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01))}
  .swipe-actions{display:flex;gap:10px}
  .pass,.like{flex:1;padding:12px 14px;border-radius:10px;font-weight:800;border:1px solid rgba(255,255,255,.12);cursor:pointer}
  .pass{background:#151515;color:#ddd}
  .like{background:linear-gradient(180deg,#f4d796,#bf9a55);color:#111}
  .match-modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6);z-index:50}
  .match-box{width:min(520px,92vw);background:#121212;border:1px solid rgba(255,255,255,.12);border-radius:16px;padding:18px;text-align:center}
  .chat{height:420px;display:flex;flex-direction:column;border-radius:12px;overflow:hidden;border:1px solid rgba(255,255,255,.1);background:#0f0f10}
  .chat-log{flex:1;overflow:auto;padding:14px;display:flex;flex-direction:column;gap:10px}
  .bubble{max-width:78%;padding:10px 12px;border-radius:12px;font-size:14px;line-height:1.35}
  .me{align-self:flex-end;background:#172015;border:1px solid rgba(225,191,120,.25)}
  .them{align-self:flex-start;background:#141414;border:1px solid rgba(255,255,255,.12)}
  .composer{display:flex;gap:8px;padding:10px;border-top:1px solid rgba(255,255,255,.08);background:#101010}
  .composer input[type="text"]{flex:1;background:#0f0f0f;border:1px solid rgba(255,255,255,.12)}
  .small{font-size:12px;color:var(--muted)} .tip{color:var(--muted);font-size:12px;margin-top:6px}
</style>
</head>
<body>
<div class="border-wrap">
  <div class="app">
    <header>
      <img src="golden-le-libido-logo.png" alt="Le Libido" onerror="this.style.opacity=.0">
      <div class="title">Blind Audio Pickup</div>
      <div class="small">Craft your pickup line with effects. Match to unlock chats.</div>
    </header>

    <div class="steps" id="stepper">
      <div class="step-pill active">1 • Record & Edit</div>
      <div class="step-pill">2 • Swipe</div>
      <div class="step-pill">3 • Chat</div>
    </div>

    <!-- STEP 1: Record & Edit -->
    <section class="panel" id="step1">
      <h2>Step 1 — Craft your pickup line</h2>
      <div class="grid cols-2">
        <div class="rec-wrap">
          <div class="row" style="align-items:center; justify-content:center; gap:18px; margin-bottom:12px">
            <button class="record-btn" id="recordBtn"><span id="recLabel">Start Recording</span></button>
            <div>
              <div class="small">Tap to record, edit with effects, keep under 15s.</div>
              <div class="tip">Use HTTPS and allow mic permission.</div>
            </div>
          </div>
          <div id="playerBlock" class="hidden">
            <div class="player">
              <button class="play-toggle" id="playToggle">▶</button>
              <div class="bar" id="seekBar"><div class="fill" id="fill"></div></div>
              <div class="time" id="time">0:00</div>
            </div>
            <div class="row" style="margin-top:10px">
              <button class="btn ghost" id="retakeBtn">Retake</button>
            </div>
            <audio id="audio" preload="metadata" class="hidden"></audio>
          </div>
          <div id="editorBlock" class="editor-wrap hidden">
            <h3>Edit Your Pickup</h3>
            <div class="timeline" id="timeline">
              <canvas id="timelineCanvas"></canvas>
              <div id="segmentsContainer" class="segments-container"></div>
            </div>
            <div class="effects">
              <button class="effect-btn" data-effect="echo">Echo</button>
              <button class="effect-btn" data-effect="pitchUp">Pitch Up</button>
              <button class="effect-btn" id="cutBtn">Cut Selection</button>
            </div>
            <div class="row" style="margin-top:10px">
              <button class="btn" id="recordEffectBtn">Record New Effect</button>
              <div id="effectsList" class="effects" style="flex:1;"></div>
            </div>
            <div class="row" style="margin-top:10px">
              <button class="btn gold" id="saveEditBtn">Save & Swipe →</button>
            </div>
          </div>
        </div>
        <div class="rec-wrap">
          <strong>Great pickup lines are:</strong>
          <ul style="margin-top:8px; color:#ddd; line-height:1.5">
            <li>Short, playful, creative with effects</li>
            <li>Flirty and fun, not cheesy</li>
            <li>Unique with sounds or vibe</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- STEP 2: Swipe -->
    <section class="panel hidden" id="step2">
      <h2>Step 2 — Swipe pickup lines</h2>
      <div class="deck" id="deck"></div>
      <div class="tip">Hear creative lines. Like to match and unlock chats.</div>
    </section>

    <!-- STEP 3: Chat -->
    <section class="panel hidden" id="step3">
      <h2>Private Chat</h2>
      <div class="chat" id="chat">
        <div class="chat-log" id="chatLog"></div>
        <div class="composer">
          <input type="text" id="chatInput" placeholder="Type a message…" />
          <input type="file" id="chatPhoto" accept="image/*" class="hidden">
          <button class="btn" id="chatPhotoBtn">📷</button>
          <button class="btn" id="chatVoiceBtn">🎙️</button>
          <button class="btn" id="callBtn">📞</button>
          <button class="btn gold" id="chatSendBtn">Send</button>
        </div>
        <div class="tip">Send texts, pics, voice memos, or start a voice call.</div>
      </div>
    </section>

    <!-- MATCH MODAL -->
    <div class="match-modal" id="matchModal" role="dialog" aria-modal="true">
      <div class="match-box">
        <h3>It’s a Match!</h3>
        <p>You both liked each other’s pickup line. Chat unlocked!</p>
        <div class="row" style="justify-content:center">
          <button class="btn ghost" id="closeMatch">Keep Swiping</button>
          <button class="btn gold" id="openChat">Open Chat</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Firebase + App logic -->
<script type="module">
  /***** FIREBASE IMPORTS *****/
  import { app, db } from './firebase-config.js';
  import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js';
  import { getStorage, ref as sRef, uploadBytes, getDownloadURL } from 'https://www.gstatic.com/firebasejs/10.12.3/firebase-storage.js';
  import { ref as rRef, set, get, onValue, push, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js';

  const auth = getAuth(app);
  const storage = getStorage(app);

  let currentUser = null;
  try { await signInAnonymously(auth); } catch (e) { console.error('Anon sign-in failed', e); }
  onAuthStateChanged(auth, u => { currentUser = u || null; });

  /***** BASIC NAV / STEP UI *****/
  const $ = s => document.querySelector(s);
  const stepper = $('#stepper').children;
  function go(i) {
    ['#step1', '#step2', '#step3'].forEach((id, idx) => {
      const el = $(id);
      if (idx === i) { el.classList.remove('hidden'); stepper[idx].classList.add('active'); }
      else { el.classList.add('hidden'); stepper[idx].classList.remove('active'); }
    });
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }
  Array.from(stepper).forEach((pill, idx) => {
    pill.style.cursor = 'pointer';
    pill.addEventListener('click', () => {
      if (idx === 1 && !window.__recBlob) { alert('Record and edit your pickup line first.'); return; }
      if (idx === 2 && !window.__activeRoom) { alert('Open a match from the deck to chat.'); return; }
      go(idx);
      if (idx === 1 && !window.__deckInit) initDeck();
    });
  });

  /***** RECORDING *****/
  const recordBtn = $('#recordBtn'), recLabel = $('#recLabel');
  const audioEl = $('#audio'), playerBlock = $('#playerBlock');
  const playToggle = $('#playToggle'), seekBar = $('#seekBar'), fill = $('#fill'), time = $('#time');
  const retakeBtn = $('#retakeBtn'), saveEditBtn = $('#saveEditBtn');
  let mediaRecorder, recChunks = [], recStream = null, recMime = '', recording = false;
  window.__recBlob = null; // pickup line blob

  function supportedMime() {
    const c = ['audio/webm;codecs=opus', 'audio/mp4;codecs=aac', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/mp4', 'audio/aac'];
    for (const t of c) { if (window.MediaRecorder?.isTypeSupported?.(t)) return t; }
    return '';
  }
  async function startRecording() {
    try {
      recMime = supportedMime();
      recStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(recStream, recMime ? { mimeType: recMime } : undefined);
      recChunks = [];
      mediaRecorder.ondataavailable = e => { if (e.data?.size) recChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        window.__recBlob = new Blob(recChunks, { type: recMime || 'audio/webm' });
        const url = URL.createObjectURL(window.__recBlob);
        audioEl.src = url;
        playerBlock.classList.remove('hidden');
        document.getElementById('editorBlock').classList.remove('hidden');
        initEditor(url);
      };
      mediaRecorder.start();
      recording = true;
      recLabel.innerHTML = '<span class="rec-indicator"></span> Recording…';
    } catch (err) { alert('Mic permission needed. Use HTTPS.'); console.error(err); }
  }
  function stopRecording() {
    if (mediaRecorder && recording) {
      mediaRecorder.stop();
      recStream?.getTracks().forEach(t => t.stop());
      recording = false;
      recLabel.textContent = 'Start Recording';
    }
  }
  recordBtn.addEventListener('click', () => recording ? stopRecording() : startRecording());

  const fmt = s => { s = Math.floor(s); const m = Math.floor(s / 60), r = s % 60; return `${m}:${r.toString().padStart(2, '0')}`; };
  function updateTime(c, d) { time.textContent = `${fmt(c)} / ${d ? fmt(d) : '0:00'}`; }
  playToggle.addEventListener('click', () => {
    if (audioEl.paused) { audioEl.play(); playToggle.textContent = '⏸'; } else { audioEl.pause(); playToggle.textContent = '▶'; }
  });
  audioEl.addEventListener('pause', () => playToggle.textContent = '▶');
  audioEl.addEventListener('play', () => playToggle.textContent = '⏸');
  audioEl.addEventListener('timeupdate', () => {
    const d = audioEl.duration || 0, c = audioEl.currentTime || 0, pct = d ? (c / d) * 100 : 0;
    fill.style.inset = `0 ${100 - pct}% 0 0`;
    updateTime(c, d);
  });
  seekBar.addEventListener('click', (e) => {
    const r = seekBar.getBoundingClientRect();
    const x = (e.clientX - r.left) / r.width;
    if (audioEl.duration) audioEl.currentTime = x * audioEl.duration;
  });
  retakeBtn.addEventListener('click', () => {
    if (!audioEl.paused) audioEl.pause();
    playerBlock.classList.add('hidden');
    document.getElementById('editorBlock').classList.add('hidden');
    window.__recBlob = null;
    audioEl.removeAttribute('src');
    // Clear editor state
    segments = [{start: 0, end: 1, buffer: null}];
    effects = [];
    $('#effectsList').innerHTML = '';
    $('#segmentsContainer').innerHTML = '';
    timelineCanvas.getContext('2d').clearRect(0, 0, timelineCanvas.width, timelineCanvas.height);
  });

  /***** AUDIO EDITOR *****/
  let audioCtx, editedBuffer, timelineCanvas = $('#timelineCanvas');
  let segments = []; // [{id, startPct, endPct, buffer}]
  let effects = []; // [{id, name, buffer}]
  let effectCounter = 0;
  let segmentCounter = 0;
  let selectedStart = null, selectedEnd = null; // For cutting selection
  async function initEditor(url) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const resp = await fetch(url);
    const arrayBuf = await resp.arrayBuffer();
    editedBuffer = await audioCtx.decodeAudioData(arrayBuf);
    segments = [{id: segmentCounter++, start: 0, end: editedBuffer.length / editedBuffer.sampleRate, buffer: editedBuffer}];
    updateSegmentsUI();
    drawWaveform();
    setupTimelineEvents();
    setupEffectDragDrop();
  }

  function drawWaveform() {
    const canvas = timelineCanvas;
    canvas.width = canvas.offsetWidth * 2; // HiDPI
    canvas.height = canvas.offsetHeight * 2;
    const ctx = canvas.getContext('2d');
    ctx.scale(2, 2);
    const width = canvas.offsetWidth;
    const height = canvas.offsetHeight;
    ctx.clearRect(0, 0, width, height);
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;

    // Combine all segments into one buffer for drawing
    const fullBuffer = mergeSegments();
    const rawData = fullBuffer.getChannelData(0);
    const samples = width;
    const blockSize = Math.floor(rawData.length / samples);
    const filteredData = [];
    for (let i = 0; i < samples; i++) {
      let blockStart = blockSize * i;
      let sum = 0;
      for (let j = 0; j < blockSize; j++) {
        sum += Math.abs(rawData[blockStart + j] || 0);
      }
      filteredData.push(sum / blockSize);
    }
    const multiplier = Math.pow(Math.max(...filteredData), -1) || 1;
    const normalizedData = filteredData.map(n => n * multiplier);

    ctx.beginPath();
    ctx.moveTo(0, height / 2);
    for (let i = 0; i < samples; i++) {
      const x = i;
      const y = (1 - normalizedData[i]) * (height / 2);
      ctx.lineTo(x, y);
    }
    for (let i = samples - 1; i >= 0; i--) {
      const x = i;
      const y = (1 + normalizedData[i]) * (height / 2);
      ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fillStyle = 'rgba(225,191,120,.5)';
    ctx.fill();
  }

  function updateSegmentsUI() {
    const container = $('#segmentsContainer');
    container.innerHTML = '';
    const timelineWidth = timelineCanvas.offsetWidth;
    segments.forEach(seg => {
      const div = document.createElement('div');
      div.className = 'segment';
      div.dataset.id = seg.id;
      div.style.left = `${(seg.start / getTotalDuration()) * 100}%`;
      div.style.width = `${((seg.end - seg.start) / getTotalDuration()) * 100}%`;
      container.appendChild(div);
      makeDraggable(div);
    });
  }

  function makeDraggable(el) {
    let startX, startLeft;
    el.addEventListener('mousedown', e => {
      startX = e.clientX;
      startLeft = parseFloat(el.style.left) || 0;
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
    function onMove(e) {
      const delta = (e.clientX - startX) / timelineCanvas.offsetWidth * 100;
      el.style.left = `${startLeft + delta}%`;
      // Snap or constrain if needed
    }
    function onUp() {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      updateSegmentTimes();
      drawWaveform();
    }
  }

  function updateSegmentTimes() {
    const totalDuration = getTotalDuration();
    segments.forEach(seg => {
      const div = document.querySelector(`.segment[data-id="${seg.id}"]`);
      const leftPct = parseFloat(div.style.left) / 100;
      const widthPct = parseFloat(div.style.width) / 100;
      seg.start = leftPct * totalDuration;
      seg.end = seg.start + widthPct * totalDuration;
    });
    // Sort segments by start
    segments.sort((a,b) => a.start - b.start);
  }

  function getTotalDuration() {
    return segments.reduce((sum, seg) => sum + (seg.end - seg.start), 0);
  }

  function mergeSegments() {
    const totalLength = segments.reduce((sum, seg) => sum + seg.buffer.length, 0);
    const merged = audioCtx.createBuffer(editedBuffer.numberOfChannels, totalLength, editedBuffer.sampleRate);
    let offset = 0;
    for (const seg of segments) {
      for (let ch = 0; ch < merged.numberOfChannels; ch++) {
        merged.copyToChannel(seg.buffer.getChannelData(ch), ch, offset);
      }
      offset += seg.buffer.length;
    }
    return merged;
  }

  function setupTimelineEvents() {
    const canvas = timelineCanvas;
    let isSelecting = false;
    let startX;
    canvas.addEventListener('mousedown', e => {
      isSelecting = true;
      startX = e.offsetX;
    });
    canvas.addEventListener('mousemove', e => {
      if (isSelecting) {
        // Show selection overlay or something
      }
    });
    canvas.addEventListener('mouseup', e => {
      if (isSelecting) {
        const endX = e.offsetX;
        selectedStart = Math.min(startX, endX) / canvas.offsetWidth;
        selectedEnd = Math.max(startX, endX) / canvas.offsetWidth;
        isSelecting = false;
      }
    });
  }

  $('#cutBtn').addEventListener('click', () => {
    if (selectedStart === null || selectedEnd === null) return alert('Select a range on the timeline first.');
    // Find segment to cut
    const totalDuration = getTotalDuration();
    const cutStartTime = selectedStart * totalDuration;
    const cutEndTime = selectedEnd * totalDuration;
    for (let i = 0; i < segments.length; i++) {
      const seg = segments[i];
      if (cutStartTime >= seg.start && cutEndTime <= seg.end) {
        // Split into left, middle (cut), right
        const leftDuration = cutStartTime - seg.start;
        const midDuration = cutEndTime - cutStartTime;
        const rightDuration = seg.end - cutEndTime;

        const leftBuffer = sliceBuffer(seg.buffer, 0, leftDuration * seg.buffer.sampleRate);
        const midBuffer = sliceBuffer(seg.buffer, leftDuration * seg.buffer.sampleRate, midDuration * seg.buffer.sampleRate);
        const rightBuffer = sliceBuffer(seg.buffer, (leftDuration + midDuration) * seg.buffer.sampleRate, rightDuration * seg.buffer.sampleRate);

        segments.splice(i, 1);
        if (leftDuration > 0) segments.push({id: segmentCounter++, start: seg.start, end: seg.start + leftDuration, buffer: leftBuffer});
        if (midDuration > 0) segments.push({id: segmentCounter++, start: cutStartTime, end: cutEndTime, buffer: midBuffer});
        if (rightDuration > 0) segments.push({id: segmentCounter++, start: cutEndTime, end: seg.end, buffer: rightBuffer});
        segments.sort((a,b) => a.start - b.start);
        updateSegmentsUI();
        drawWaveform();
        selectedStart = selectedEnd = null;
        break;
      }
    }
  });

  function sliceBuffer(buffer, startSample, lengthSamples) {
    const numChannels = buffer.numberOfChannels;
    const newBuffer = audioCtx.createBuffer(numChannels, lengthSamples, buffer.sampleRate);
    for (let ch = 0; ch < numChannels; ch++) {
      const newData = newBuffer.getChannelData(ch);
      const origData = buffer.getChannelData(ch);
      for (let i = 0; i < lengthSamples; i++) {
        newData[i] = origData[startSample + i] || 0;
      }
    }
    return newBuffer;
  }

  // Effects (predefined)
  document.querySelectorAll('.effect-btn:not(#cutBtn)').forEach(btn => {
    btn.addEventListener('click', async () => {
      const effect = btn.dataset.effect;
      // Apply to whole for simplicity, or to selected
      if (effect === 'echo') {
        editedBuffer = await applyEcho(editedBuffer);
      } else if (effect === 'pitchUp') {
        editedBuffer = await applyPitchShift(editedBuffer, 1.2);
      }
      updatePreview();
      drawWaveform();
    });
  });

  async function applyEcho(buffer) {
    const offlineCtx = new OfflineAudioContext(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
    const source = offlineCtx.createBufferSource();
    source.buffer = buffer;
    const convolver = offlineCtx.createConvolver();
    const impulse = offlineCtx.createBuffer(2, offlineCtx.sampleRate * 0.5, offlineCtx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
      const data = impulse.getChannelData(ch);
      for (let i = 0; i < impulse.length; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / impulse.length) * 0.2;
      }
    }
    convolver.buffer = impulse;
    source.connect(convolver);
    convolver.connect(offlineCtx.destination);
    source.start();
    return await offlineCtx.startRendering();
  }

  async function applyPitchShift(buffer, rate) {
    const offlineCtx = new OfflineAudioContext(buffer.numberOfChannels, buffer.length / rate, buffer.sampleRate);
    const source = offlineCtx.createBufferSource();
    source.buffer = buffer;
    source.playbackRate.value = rate;
    source.connect(offlineCtx.destination);
    source.start();
    return await offlineCtx.startRendering();
  }

  // Record new effects
  let effectRecorder, effectChunks = [], effectStream;
  $('#recordEffectBtn').addEventListener('click', async () => {
    if (!effectRecorder) {
      try {
        effectStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        effectRecorder = new MediaRecorder(effectStream);
        effectChunks = [];
        effectRecorder.ondataavailable = e => effectChunks.push(e.data);
        effectRecorder.onstop = async () => {
          const blob = new Blob(effectChunks, { type: 'audio/webm' });
          const url = URL.createObjectURL(blob);
          const resp = await fetch(url);
          const arrayBuf = await resp.arrayBuffer();
          const buf = await audioCtx.decodeAudioData(arrayBuf);
          const id = effectCounter++;
          effects.push({id, name: `Effect ${id + 1}`, buffer: buf});
          addEffectUI(id, `Effect ${id + 1}`);
        };
        effectRecorder.start();
        $('#recordEffectBtn').textContent = 'Stop Recording Effect';
      } catch (err) { alert('Mic access needed.'); }
    } else {
      effectRecorder.stop();
      effectStream.getTracks().forEach(t => t.stop());
      effectRecorder = null;
      $('#recordEffectBtn').textContent = 'Record New Effect';
    }
  });

  function addEffectUI(id, name) {
    const list = $('#effectsList');
    const div = document.createElement('div');
    div.className = 'effect-item';
    div.draggable = true;
    div.textContent = name;
    div.dataset.id = id;
    list.appendChild(div);
  }

  function setupEffectDragDrop() {
    document.querySelectorAll('.effect-item').forEach(item => {
      item.addEventListener('dragstart', e => {
        e.dataTransfer.setData('effectId', item.dataset.id);
      });
    });
    const timeline = $('#timeline');
    timeline.addEventListener('dragover', e => e.preventDefault());
    timeline.addEventListener('drop', async e => {
      e.preventDefault();
      const effectId = e.dataTransfer.getData('effectId');
      const effect = effects.find(ef => ef.id == effectId);
      if (!effect) return;
      const rect = timeline.getBoundingClientRect();
      const dropX = e.clientX - rect.left;
      const dropTime = (dropX / rect.width) * getTotalDuration();
      // Mix effect into merged buffer at dropTime
      const merged = mergeSegments();
      editedBuffer = await mixBufferAtTime(merged, effect.buffer, dropTime);
      // Update segments or just redraw
      segments = [{id: segmentCounter++, start: 0, end: editedBuffer.duration, buffer: editedBuffer}];
      updateSegmentsUI();
      drawWaveform();
      updatePreview();
    });
  }

  async function mixBufferAtTime(mainBuffer, addBuffer, atTime) {
    const offsetSamples = Math.floor(atTime * mainBuffer.sampleRate);
    const newLength = Math.max(mainBuffer.length, offsetSamples + addBuffer.length);
    const offlineCtx = new OfflineAudioContext(mainBuffer.numberOfChannels, newLength, mainBuffer.sampleRate);
    const mainSource = offlineCtx.createBufferSource();
    mainSource.buffer = mainBuffer;
    mainSource.connect(offlineCtx.destination);
    mainSource.start(0);
    const addSource = offlineCtx.createBufferSource();
    addSource.buffer = addBuffer;
    addSource.connect(offlineCtx.destination);
    addSource.start(atTime);
    return await offlineCtx.startRendering();
  }

  async function updatePreview() {
    const merged = mergeSegments();
    const blob = await audioBufferToBlob(merged);
    audioEl.src = URL.createObjectURL(blob);
  }

  async function audioBufferToBlob(buffer) {
    const offlineCtx = new OfflineAudioContext(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
    const src = offlineCtx.createBufferSource();
    src.buffer = buffer;
    src.connect(offlineCtx.destination);
    src.start();
    const rendered = await offlineCtx.startRendering();
    const wav = await audioBufferToWav(rendered);
    return new Blob([wav], { type: 'audio/wav' });
  }

  async function audioBufferToWav(buffer) {
    // Same as before
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const length = buffer.length * numChannels * 2 + 44;
    const arrayBuffer = new ArrayBuffer(length);
    const view = new DataView(arrayBuffer);

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    let offset = 0;
    writeString(view, offset, 'RIFF'); offset += 4;
    view.setUint32(offset, 36 + buffer.length * numChannels * 2, true); offset += 4;
    writeString(view, offset, 'WAVE'); offset += 4;
    writeString(view, offset, 'fmt '); offset += 4;
    view.setUint32(offset, 16, true); offset += 4;
    view.setUint16(offset, 1, true); offset += 2;
    view.setUint16(offset, numChannels, true); offset += 2;
    view.setUint32(offset, sampleRate, true); offset += 4;
    view.setUint32(offset, sampleRate * numChannels * 2, true); offset += 4;
    view.setUint16(offset, numChannels * 2, true); offset += 2;
    view.setUint16(offset, 16, true); offset += 2;
    writeString(view, offset, 'data'); offset += 4;
    view.setUint32(offset, buffer.length * numChannels * 2, true); offset += 4;

    for (let i = 0; i < buffer.length; i++) {
      for (let ch = 0; ch < numChannels; ch++) {
        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(ch)[i]));
        view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
        offset += 2;
      }
    }
    return arrayBuffer;
  }

  saveEditBtn.addEventListener('click', async () => {
    if (!window.__recBlob) { alert('Record and edit your pickup line first.'); return; }
    const merged = mergeSegments();
    window.__recBlob = await audioBufferToBlob(merged);
    const lineRef = sRef(storage, `lines/${currentUser.uid}/${Date.now()}.wav`);
    await uploadBytes(lineRef, window.__recBlob, { contentType: 'audio/wav' });
    const lineURL = await getDownloadURL(lineRef);
    await set(rRef(db, `lines/${currentUser.uid}`), { uid: currentUser.uid, lineURL, ts: serverTimestamp() });
    go(1);
    initDeck();
  });

  /***** SWIPE: AUDIO LINES *****/
  // ... (unchanged from previous)

  /***** MATCHING *****/
  // ... (unchanged)

  /***** CHAT (Realtime DB + Storage + WebRTC) *****/
  // ... (unchanged)

  /***** START APP *****/
  go(0);
</script>
</body>
</html>