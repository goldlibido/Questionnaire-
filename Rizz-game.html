<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Rizzler: Drop Your Best Line</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root{--gold:#e1bf78;--blue:#064D95;--green:#06954E;--red:#c40018;--redBright:#ff1e2d;}
    body{font-family:'Montserrat',sans-serif;background:#000;color:#fff;text-align:center;padding:20px;margin:0;overflow:hidden}
    .container{max-width:640px;margin:0 auto;border:2px solid var(--gold);border-radius:15px;padding:20px;box-shadow:0 0 20px var(--gold)}
    h1{font-size:2em;color:var(--gold);margin-bottom:10px}
    h1 .pulse{color:var(--redBright);display:inline-block;animation:pulse 1.4s ease-in-out infinite}
    @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.15)}100%{transform:scale(1)}}
    button{padding:14px 26px;margin:10px;font-size:1.05em;border:none;border-radius:24px;cursor:pointer;transition:transform .2s,box-shadow .2s;color:#fff}
    button:hover{transform:scale(1.06);box-shadow:0 0 10px currentColor}
    #enter-btn{background:var(--red)}
    #speak-btn{background:var(--green)}
    #listen-btn{background:var(--blue)}
    #next-btn{background:var(--red)}
    #profile-form,#listen-section{margin-top:18px}
    input[type="text"]{padding:10px;margin:5px;border:1px solid var(--gold);border-radius:10px;background:#222;color:#fff;width:calc(100% - 24px)}
    .hidden{display:none}
    #me-line{opacity:.9;margin:10px 0 6px}
    #status{opacity:.9;min-height:1.2em}
    #audio-player{margin:16px auto;width:100%}
    body::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle,rgba(225,191,120,.1) 0%,rgba(0,0,0,0) 100%);z-index:-1}
  </style>
</head>
<body>
  <div class="container">
    <h1>Rizzler: Unleash Your <span class="pulse">Rizz</span>!</h1>

    <div id="profile-form">
      <input type="text" id="display-name" placeholder="Your display name (optional)">
      <button id="enter-btn">Enter the Game</button>
      <div id="me-line" class="hidden"></div>
      <div id="status"></div>
    </div>

    <div id="main-section" class="hidden">
      <button id="speak-btn">Speak & Rizz</button>
      <button id="listen-btn">Listen & Get Rizzed</button>
      <button id="next-btn">Next Match</button>
    </div>

    <div id="listen-section" class="hidden">
      <audio id="audio-player" controls crossorigin="anonymous" playsinline></audio>
    </div>
  </div>

  <!-- PeerJS -->
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

  <!-- App (ES module) -->
  <script type="module">
    /********** Imports **********/
    import { db } from './firebase-config.js';
    import {
      ref, push, set, onValue, onDisconnect, remove, update, get,
      runTransaction, serverTimestamp, query, orderByChild, equalTo,
      limitToFirst, endAt
    } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js";

    /********** Config **********/
    const QUEUE_TTL_MS = 30000;
    const CLAIM_BATCH  = 8;
    const CHUNK_SIZE   = 16 * 1024;

    /********** State **********/
    let peer;               // PeerJS Peer
    let myPeerId = null;    // my random id
    let partnerId = null;   // matched partner id
    let conn = null;        // PeerJS DataConnection (for chunks/messages)

    // Recorder state (matches your working snippet)
    let mediaRecorder = null;
    let recordingStream = null;
    let audioChunks = [];

    // Receiver reassembly buffers (matches your working snippet)
    let incomingChunks = [];
    let incomingMime = 'audio/webm;codecs=opus';
    let incomingSize = 0;

    // Firebase refs
    let myTicketRef = null;
    let myPairRef = null;
    let requeueTimer = null;

    // UI helpers
    const $ = s => document.querySelector(s);
    function setStatus(s){ $('#status').textContent = s || ''; }
    function show(el){ el.classList.remove('hidden'); }
    function hide(el){ el.classList.add('hidden'); }

    /********** EXACT working helpers from your snippet **********/
    function getSupportedMime() {
      const tryTypes = [
        'audio/webm;codecs=opus',
        'audio/webm',
        'audio/mp4',            // iOS Safari often supports this
        'audio/ogg;codecs=opus'
      ];
      for (const t of tryTypes) {
        if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) {
          return t;
        }
      }
      return '';
    }

    function playBlobInAudio(blob) {
      const audio = $('#audio-player');
      const url = URL.createObjectURL(blob);
      audio.srcObject = null;
      audio.src = url;
      audio.load();
      // User will tap play (or it may auto-play if already interacted)
      audio.play().catch(()=>{});
    }

    // Chunked send over data channel — EXACT pattern you provided
    function sendBlobInChunks(blob, mimeType) {
      if (!conn || !conn.open) {
        alert('Not connected to a peer to send your line.');
        return;
      }
      conn.send({ type: 'audio-start', mime: mimeType, size: blob.size });

      const reader = new FileReader();
      let offset = 0;

      reader.onload = (e) => {
        const arr = new Uint8Array(e.target.result);
        conn.send({ type: 'audio-chunk', data: arr });
        offset += arr.length;

        if (offset < blob.size) {
          readNextChunk();
        } else {
          conn.send({ type: 'audio-end' });
          setStatus('Line sent!');
        }
      };

      function readNextChunk() {
        const slice = blob.slice(offset, offset + CHUNK_SIZE);
        reader.readAsArrayBuffer(slice);
      }

      readNextChunk();
    }

    /********** PeerJS **********/
    async function initPeer(){
      peer = new Peer(undefined,{
        debug: 2,
        config:{ iceServers:[
          {urls:'stun:stun.l.google.com:19302'},
          {urls:'stun:stun1.l.google.com:19302'},
          {urls:'stun:stun2.l.google.com:19302'}
        ]}
      });

      peer.on('open', id => {
        myPeerId = id;
        show($('#me-line'));
        $('#me-line').textContent = `Your ID: ${id}`;
        setStatus('Finding a random match…');
        joinQueue();
      });

      // If the OTHER side initiates the data connection
      peer.on('connection', (connection) => {
        // Accept inbound connection; wire up handlers
        establishConn(connection, /*openedByUs=*/false);
      });

      // We are NOT doing PeerJS media calls here (no live stream), only data channel
      peer.on('call', (call) => {
        // In case someone tries to call, immediately close — this build uses only recorded clips
        try { call.close(); } catch {}
      });

      peer.on('disconnected', ()=>{ try{peer.reconnect();}catch{} });
      peer.on('error', e => console.error('Peer error:', e));
    }

    // Create (or accept) a single data connection and wire events
    function establishConn(connection, openedByUs){
      if (conn && conn.open && connection.peer !== conn.peer) { try{ connection.close(); }catch{} return; }
      conn = connection;

      conn.on('open', () => {
        setStatus('Matched! You can Speak or Listen.');
        hide($('#profile-form'));
        show($('#main-section'));
        // No need to send profile payloads; we only exchange audio chunks
      });

      conn.on('data', handleData);

      conn.on('close', () => {
        setStatus('Partner left. Re-queuing…');
        conn = null;
        partnerId = null;
        joinQueue();
      });

      conn.on('error', (e) => {
        console.error('Conn error:', e);
        setStatus('Connection error. Re-queuing…');
        conn = null;
        partnerId = null;
        joinQueue();
      });
    }

    // If we are the lexicographically smaller ID, we initiate the data channel to avoid double dials
    function maybeInitiateConnection(){
      if (!partnerId || !myPeerId) return;
      if (conn && conn.open) return;
      if (myPeerId < partnerId) {
        const c = peer.connect(partnerId, { reliable:true });
        establishConn(c, /*openedByUs=*/true);
      }
      // Else: wait for the other side's connect()
    }

    /********** Firebase matchmaking **********/
    function joinQueue(){
      // 1) create my ticket
      myTicketRef = push(ref(db, 'queue'));
      set(myTicketRef, { peer: myPeerId, claimed: false, ts: serverTimestamp() });
      onDisconnect(myTicketRef).remove();

      // 2) watch if someone pairs us
      myPairRef = ref(db, 'pairs/'+myPeerId);
      onDisconnect(myPairRef).remove();
      onValue(myPairRef, (snap)=>{
        const v = snap.val();
        if (v?.partner && !partnerId) {
          partnerId = v.partner;
          clearTimeout(requeueTimer);
          maybeInitiateConnection();
        }
      });

      // 3) clean & try to claim a partner
      cleanupStaleTickets(importCandidatesAndClaim);

      // 4) re-queue if nobody soon
      requeueTimer = setTimeout(() => {
        if (!partnerId) {
          setStatus('No match yet. Re-queuing…');
          safeRemove(myTicketRef);
          safeRemove(myPairRef);
          joinQueue();
        }
      }, QUEUE_TTL_MS);
    }

    function importCandidatesAndClaim(){
      const q = query(ref(db, 'queue'), orderByChild('claimed'), equalTo(false), limitToFirst(CLAIM_BATCH));
      get(q).then((snap)=>{
        const cands = [];
        snap.forEach(cs=>{
          const v = cs.val();
          if (v && v.peer && v.peer !== myPeerId && isFresh(v.ts)) {
            cands.push({ key: cs.key, peer: v.peer, ts: v.ts });
          }
        });
        tryClaim(cands, 0);
      });
    }

    function tryClaim(list, i){
      if (partnerId || i >= list.length) { setStatus('Waiting for someone…'); return; }
      const cand = list[i];
      const claimPath = ref(db, `queue/${cand.key}/claimed`);
      runTransaction(claimPath, cur => cur === false ? myPeerId : cur)
        .then(res=>{
          if (res.committed && res.snapshot.val() === myPeerId) {
            const updates = {};
            updates[`pairs/${myPeerId}`] = { partner: cand.peer, ts: Date.now() };
            updates[`pairs/${cand.peer}`] = { partner: myPeerId, ts: Date.now() };
            updates[`queue/${myTicketRef.key}`] = null;
            updates[`queue/${cand.key}`] = null;
            update(ref(db), updates).then(()=>{
              partnerId = cand.peer;
              clearTimeout(requeueTimer);
              maybeInitiateConnection();
            });
          } else {
            tryClaim(list, i+1);
          }
        })
        .catch(()=> tryClaim(list, i+1));
    }

    function cleanupStaleTickets(done){
      const cutoff = Date.now() - QUEUE_TTL_MS;
      const q = query(ref(db, 'queue'), orderByChild('ts'), endAt(cutoff), limitToFirst(25));
      get(q).then((snap)=>{
        const updates = {};
        snap.forEach(cs=>{
          const v = cs.val();
          if (v && v.ts && v.ts < cutoff) updates[`queue/${cs.key}`] = null;
        });
        if (Object.keys(updates).length) update(ref(db), updates).finally(()=>done && done());
        else done && done();
      });
    }

    function isFresh(ts){ return !ts || (Date.now() - ts) < QUEUE_TTL_MS; }
    function safeRemove(r){ try{ r && remove(r); }catch{} }

    /********** UI: recording & listening **********/
    $('#enter-btn').addEventListener('click', async () => {
      hide($('#profile-form'));
      show($('#main-section'));
      setStatus('Initializing…');
      await initPeer();
    });

    // RECORD → SEND (uses your working flow)
    $('#speak-btn').addEventListener('click', () => {
      if (!conn || !conn.open) { setStatus('Connecting… please wait a sec.'); return; }
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        // stop
        mediaRecorder.stop();
        return;
      }
      // start
      navigator.mediaDevices.getUserMedia({ audio: true }).then((s) => {
        recordingStream = s;

        const mimeType = getSupportedMime(); // same choice order as your code
        try {
          mediaRecorder = new MediaRecorder(recordingStream, mimeType ? { mimeType } : {});
        } catch (e) {
          alert('MediaRecorder failed to start: ' + e.message);
          return;
        }

        audioChunks = [];
        mediaRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) {
            audioChunks.push(e.data);
          }
        };
        mediaRecorder.onstop = () => {
          // Stop mic
          recordingStream.getTracks().forEach(t => t.stop());
          // Build final blob and send in chunks — IDENTICAL to your working logic
          const finalMime = mediaRecorder.mimeType || mimeType || 'audio/webm';
          const blob = new Blob(audioChunks, { type: finalMime });
          sendBlobInChunks(blob, finalMime);
          $('#speak-btn').textContent = 'Speak & Rizz';
        };

        mediaRecorder.start(100); // collect 100ms chunks
        $('#speak-btn').textContent = 'Stop Recording';
        setStatus('Recording…');
      }).catch((e) => {
        alert('Microphone access denied: ' + e.message);
      });
    });

    // LISTEN — just shows the player and primes autoplay by a user gesture
    $('#listen-btn').addEventListener('click', () => {
      show($('#listen-section'));
      const a = $('#audio-player');
      a.muted = false;
      a.play().catch(()=>{}); // primes autoplay after human gesture
      setStatus('Armed to listen…');
    });

    // NEXT — drop current pairing and requeue
    $('#next-btn').addEventListener('click', () => {
      try{ conn?.close(); }catch{}
      conn = null;
      partnerId = null;
      $('#audio-player').src = '';
      setStatus('Re-matching…');
      joinQueue();
    });

    /********** Incoming data handler — EXACT behavior you shared **********/
    function handleData(msg) {
      if (!msg || !msg.type) return;

      switch (msg.type) {
        case 'audio-start':
          incomingChunks = [];
          incomingMime = msg.mime || 'audio/webm;codecs=opus';
          incomingSize = msg.size || 0;
          setStatus('Receiving a line…');
          break;

        case 'audio-chunk':
          // msg.data arrives as Uint8Array via PeerJS
          incomingChunks.push(msg.data);
          break;

        case 'audio-end': {
          const blob = new Blob(incomingChunks, { type: incomingMime });
          playBlobInAudio(blob);
          setStatus('Line received!');
          break;
        }
      }
    }
  </script>
</body>
</html>