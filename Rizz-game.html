<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Rizzler: Drop Your Best Line</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root{--gold:#e1bf78;--blue:#064D95;--green:#06954E;--red:#c40018;--redBright:#ff1e2d;}
    body{font-family:'Montserrat',sans-serif;background:#000;color:#fff;text-align:center;padding:20px;margin:0;overflow:hidden}
    .container{max-width:640px;margin:0 auto;border:2px solid var(--gold);border-radius:15px;padding:20px;box-shadow:0 0 20px var(--gold)}
    h1{font-size:2em;color:var(--gold);margin-bottom:10px}
    h1 .pulse{color:var(--redBright);display:inline-block;animation:pulse 1.4s ease-in-out infinite}
    @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.15)}100%{transform:scale(1)}}
    button{padding:14px 26px;margin:10px;font-size:1.05em;border:none;border-radius:24px;cursor:pointer;transition:transform .2s,box-shadow .2s;color:#fff}
    button:hover{transform:scale(1.06);box-shadow:0 0 10px currentColor}
    #enter-btn{background:var(--red)}
    #speak-btn{background:var(--green)}
    #listen-btn{background:var(--blue)}
    #accept-btn{background:var(--red)}
    #send-btn,#audio-send-btn{background:var(--green)}
    #photo-btn{background:var(--blue)}
    input[type="text"]{padding:10px;margin:5px;border:1px solid var(--gold);border-radius:10px;background:#222;color:#fff;width:calc(100% - 24px)}
    .hidden{display:none}
    #me-line{opacity:.9;margin:10px 0 6px}
    #status{opacity:.9;min-height:1.2em}
    #audio-player{margin:16px auto;width:100%}
    #chat-window{height:260px;overflow-y:auto;border:1px solid var(--gold);border-radius:10px;padding:10px;background:#111;margin-bottom:10px;text-align:left}
    .chat-message{padding:8px 10px;margin:6px 0;border-radius:12px;max-width:85%;word-wrap:break-word;animation:slideIn .3s ease-out;display:inline-block}
    .sent{background:var(--green);margin-left:auto}
    .received{background:var(--blue);margin-right:auto}
    .toolbar{display:flex;gap:8px;align-items:center;justify-content:center;flex-wrap:wrap;margin-top:8px}
    .toolbar input[type="text"]{flex:1;min-width:160px}
    .tiny{font-size:.9em;opacity:.85;margin-top:6px}
    @keyframes slideIn{from{transform:translateY(14px);opacity:0}to{transform:translateY(0);opacity:1}}
    body::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle,rgba(225,191,120,.1) 0%,rgba(0,0,0,0) 100%);z-index:-1}
  </style>
</head>
<body>
  <div class="container">
    <h1>Rizzler: Unleash Your <span class="pulse">Rizz</span>!</h1>

    <!-- Profile -->
    <div id="profile-form">
      <input type="text" id="display-name" placeholder="Your display name (optional)">
      <button id="enter-btn">Enter the Game</button>
      <div id="me-line" class="hidden"></div>
      <div id="status"></div>
    </div>

    <!-- Main actions -->
    <div id="main-section" class="hidden">
      <button id="speak-btn">Speak & Rizz</button>
      <button id="listen-btn">Listen & Get Rizzed</button>
    </div>

    <!-- Speak flow -->
    <div id="speak-section" class="hidden">
      <p><strong>Record your line:</strong></p>
      <button id="record-toggle">Start Recording</button>
      <div class="tiny">Tap once to start; tap again to stop & send.</div>
    </div>

    <!-- Listen flow -->
    <div id="listen-section" class="hidden">
      <audio id="audio-player" controls crossorigin="anonymous" playsinline></audio>
      <div style="margin-top:8px">
        <button id="accept-btn" class="hidden">Accept & Match</button>
      </div>
      <div class="tiny">Audio will play here when a line arrives.</div>
    </div>

    <!-- Match / Chat -->
    <div id="match-section" class="hidden">
      <h2>Match! Let the Sparks Fly!</h2>
      <p id="match-info"></p>
      <div id="chat-window"></div>
      <div class="toolbar">
        <input type="text" id="chat-input" placeholder="Type your message‚Ä¶">
        <button id="send-btn">Send</button>

        <input id="photo-input" class="hidden" type="file" accept="image/*" capture="environment">
        <button id="photo-btn">üì∑ Photo</button>

        <button id="audio-send-btn" title="Tap to record an audio reply">üéôÔ∏è Audio</button>
      </div>
      <div class="tiny">Tip: tap üéôÔ∏è to record and send an audio reply.</div>
    </div>
  </div>

  <!-- PeerJS -->
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

  <!-- App (ESM) -->
  <script type="module">
    /********** Imports **********/
    import { db } from './firebase-config.js';
    import {
      ref, push, set, onValue, onDisconnect, remove, update, get,
      runTransaction, serverTimestamp, query, orderByChild, equalTo,
      limitToFirst, endAt
    } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js";

    /********** Config **********/
    const QUEUE_TTL_MS = 30000;
    const CLAIM_BATCH  = 8;
    const CHUNK_SIZE   = 16 * 1024;

    /********** State **********/
    let peer, conn;
    let myPeerId = null, partnerId = null;
    let userProfile = {}, remoteProfile = {};
    let matched = false;

    // Recorder state (for speak & chat audio)
    let mediaRecorder = null, recordingStream = null, audioChunks = [];
    let chatRecorder = null, chatStream = null, chatChunks = [];

    // Receiver reassembly
    let incomingChunks = [], incomingMime = 'audio/webm;codecs=opus', incomingSize = 0;
    // For chat audio (separate buffer)
    let rxChat = { parts: [], mime: 'audio/webm;codecs=opus' };

    // Image RX
    let rxImage = { parts: [], mime: 'image/jpeg', name: 'photo.jpg' };

    // Firebase refs
    let myTicketRef = null, myPairRef = null, requeueTimer = null;

    /********** DOM helpers **********/
    const $ = s => document.querySelector(s);
    const setStatus = s => $('#status').textContent = s || '';
    const show = el => el.classList.remove('hidden');
    const hide = el => el.classList.add('hidden');

    /********** iOS-friendly MIME choice **********/
    function getSupportedMime() {
      const types = ['audio/mp4', 'audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus'];
      for (const t of types) {
        if (window.MediaRecorder?.isTypeSupported?.(t)) return t;
      }
      return '';
    }

    function playBlobInAudio(blob) {
      const audio = $('#audio-player');
      const url = URL.createObjectURL(blob);
      audio.srcObject = null;
      audio.src = url;
      audio.load();
      audio.play().catch(()=>{}); // permitted after Listen tap
    }

    /********** PeerJS **********/
    async function initPeer(){
      peer = new Peer(undefined,{
        debug:2,
        config:{ iceServers:[
          {urls:'stun:stun.l.google.com:19302'},
          {urls:'stun:stun1.l.google.com:19302'},
          {urls:'stun:stun2.l.google.com:19302'}
        ]}
      });

      peer.on('open', id => {
        myPeerId = id;
        show($('#me-line'));
        $('#me-line').textContent = `Your ID: ${id}`;
        setStatus('Finding a random match‚Ä¶');
        joinQueue();
      });

      // Accept inbound data channel
      peer.on('connection', (connection) => {
        establishConn(connection);
      });

      // We do NOT use PeerJS media calls here (only data channel)
      peer.on('call', call => { try{ call.close(); }catch{} });

      peer.on('disconnected', ()=>{ try{peer.reconnect();}catch{} });
      peer.on('error', e => console.error('Peer error:', e));
    }

    function establishConn(connection){
      if (conn && conn.open && connection.peer !== conn.peer) { try{connection.close();}catch{}; return; }
      conn = connection;

      conn.on('open', () => {
        setStatus('Matched! Choose Speak or Listen.');
        hide($('#profile-form'));
        show($('#main-section'));
        // exchange names if desired
        conn.send({ type:'profile', data:userProfile });
      });
      conn.on('data', handleData);
      conn.on('close', onDisconnect);
      conn.on('error', onDisconnect);
    }

    function maybeInitiateConnection(){
      if (!partnerId || !myPeerId) return;
      if (conn && conn.open) return;
      if (myPeerId < partnerId) {
        const c = peer.connect(partnerId, { reliable:true });
        establishConn(c);
      }
    }

    function onDisconnect(){
      setStatus('Partner left. Matching again‚Ä¶');
      conn = null; partnerId = null; matched = false;
      hide($('#speak-section')); hide($('#listen-section')); hide($('#match-section'));
      show($('#main-section'));
      joinQueue();
    }

    /********** Firebase matchmaking **********/
    function joinQueue(){
      myTicketRef = push(ref(db, 'queue'));
      set(myTicketRef, { peer: myPeerId, claimed:false, ts: serverTimestamp() });
      onDisconnect(myTicketRef).remove();

      myPairRef = ref(db, 'pairs/'+myPeerId);
      onDisconnect(myPairRef).remove();
      onValue(myPairRef, (snap)=>{
        const v = snap.val();
        if (v?.partner && !partnerId) {
          partnerId = v.partner;
          clearTimeout(requeueTimer);
          maybeInitiateConnection();
        }
      });

      cleanupStaleTickets(importCandidatesAndClaim);

      requeueTimer = setTimeout(() => {
        if (!partnerId) {
          setStatus('No match yet. Re-queuing‚Ä¶');
          safeRemove(myTicketRef); safeRemove(myPairRef);
          joinQueue();
        }
      }, QUEUE_TTL_MS);
    }

    function importCandidatesAndClaim(){
      const q = query(ref(db, 'queue'), orderByChild('claimed'), equalTo(false), limitToFirst(CLAIM_BATCH));
      get(q).then((snap)=>{
        const cands = [];
        snap.forEach(cs=>{
          const v = cs.val();
          if (v && v.peer && v.peer !== myPeerId && isFresh(v.ts)) cands.push({ key: cs.key, peer: v.peer, ts: v.ts });
        });
        tryClaim(cands, 0);
      });
    }

    function tryClaim(list, i){
      if (partnerId || i >= list.length) { setStatus('Waiting for someone‚Ä¶'); return; }
      const cand = list[i];
      const claimPath = ref(db, `queue/${cand.key}/claimed`);
      runTransaction(claimPath, cur => cur === false ? myPeerId : cur)
        .then(res=>{
          if (res.committed && res.snapshot.val() === myPeerId) {
            const updates = {};
            updates[`pairs/${myPeerId}`] = { partner: cand.peer, ts: Date.now() };
            updates[`pairs/${cand.peer}`] = { partner: myPeerId, ts: Date.now() };
            updates[`queue/${myTicketRef.key}`] = null;
            updates[`queue/${cand.key}`] = null;
            update(ref(db), updates).then(()=>{
              partnerId = cand.peer;
              clearTimeout(requeueTimer);
              maybeInitiateConnection();
            });
          } else {
            tryClaim(list, i+1);
          }
        })
        .catch(()=> tryClaim(list, i+1));
    }

    function cleanupStaleTickets(done){
      const cutoff = Date.now() - QUEUE_TTL_MS;
      const q = query(ref(db, 'queue'), orderByChild('ts'), endAt(cutoff), limitToFirst(25));
      get(q).then((snap)=>{
        const updates = {};
        snap.forEach(cs=>{
          const v = cs.val();
          if (v && v.ts && v.ts < cutoff) updates[`queue/${cs.key}`] = null;
        });
        if (Object.keys(updates).length) update(ref(db), updates).finally(()=>done && done());
        else done && done();
      });
    }

    function isFresh(ts){ return !ts || (Date.now() - ts) < QUEUE_TTL_MS; }
    function safeRemove(r){ try{ r && remove(r); }catch{} }

    /********** UI Flow **********/
    $('#enter-btn').addEventListener('click', async () => {
      userProfile.name = ($('#display-name').value || '').trim() || 'Rizzler';
      hide($('#profile-form'));
      show($('#main-section'));
      setStatus('Initializing‚Ä¶');
      await initPeer();
    });

    // SPEAK & RIZZ ‚Üí uses your working MediaRecorder‚ÜíBlob‚Üíchunk flow
    $('#speak-btn').addEventListener('click', () => {
      if (!conn || !conn.open) { setStatus('Connecting‚Ä¶'); return; }
      hide($('#listen-section')); show($('#speak-section'));
    });

    // Start/Stop Recording (Safari-friendly: called only on click)
    $('#record-toggle').addEventListener('click', () => {
      if (!mediaRecorder || mediaRecorder.state !== 'recording') {
        // START
        navigator.mediaDevices.getUserMedia({ audio:true }).then(s=>{
          recordingStream = s;
          const mimeType = getSupportedMime();
          try { mediaRecorder = new MediaRecorder(recordingStream, mimeType?{ mimeType }:{}); }
          catch(e){ alert('Recorder failed: '+e.message); return; }

          audioChunks = [];
          mediaRecorder.ondataavailable = e => { if (e.data && e.data.size>0) audioChunks.push(e.data); };
          mediaRecorder.onstop = () => {
            recordingStream.getTracks().forEach(t=>t.stop());
            const finalMime = mediaRecorder.mimeType || mimeType || 'audio/webm';
            const blob = new Blob(audioChunks, { type: finalMime });
            sendAudioBlob(blob, finalMime); // <‚Äî chunked send
            $('#record-toggle').textContent = 'Start Recording';
            setStatus('Line sent!');
          };
          mediaRecorder.start(100);
          $('#record-toggle').textContent = 'Stop Recording';
          setStatus('Recording‚Ä¶');
        }).catch(e=>{ alert('Microphone access denied: ' + e.message); });
      } else {
        // STOP
        mediaRecorder.stop();
      }
    });

    // LISTEN & GET RIZZED ‚Üí primes autoplay
    $('#listen-btn').addEventListener('click', () => {
      if (!conn || !conn.open) { setStatus('Connecting‚Ä¶'); return; }
      hide($('#speak-section')); show($('#listen-section'));
      const a = $('#audio-player'); a.muted = false; a.play().catch(()=>{});
      setStatus('Armed to listen‚Ä¶');
    });

    // ACCEPT ‚Üí open chat
    $('#accept-btn').addEventListener('click', () => {
      if (!conn || !conn.open) return;
      conn.send({ type:'accept', data:userProfile });
      matched = true;
      showMatch(remoteProfile || { name:'Mystery' });
    });

    /********** Chat: text, photo, audio replies **********/
    $('#send-btn').addEventListener('click', () => {
      const input = $('#chat-input'); const msg = input.value.trim();
      if (!msg || !(conn && conn.open)) return;
      conn.send({ type:'message', data: msg });
      displayMessage(msg, true);
      input.value = '';
    });

    $('#photo-btn').addEventListener('click', () => $('#photo-input').click());
    $('#photo-input').addEventListener('change', e => {
      const f = e.target.files?.[0]; if (!f || !(conn && conn.open)) return;
      f.arrayBuffer().then(buf => {
        const b = new Blob([buf], { type: f.type || 'image/jpeg' });
        appendImg(b, true);
        sendImg(b, f.name || 'photo.jpg');
        e.target.value = '';
      });
    });

    // Tap to record an audio reply (toggles start/stop)
    $('#audio-send-btn').addEventListener('click', () => {
      if (!chatRecorder || chatRecorder.state !== 'recording') {
        navigator.mediaDevices.getUserMedia({ audio:true }).then(s=>{
          chatStream = s;
          const mimeType = getSupportedMime();
          try { chatRecorder = new MediaRecorder(chatStream, mimeType?{ mimeType }:{}); }
          catch(e){ alert('Recorder failed: '+e.message); return; }
          chatChunks = [];
          chatRecorder.ondataavailable = e => { if (e.data && e.data.size>0) chatChunks.push(e.data); };
          chatRecorder.onstop = () => {
            chatStream.getTracks().forEach(t=>t.stop());
            const finalMime = chatRecorder.mimeType || mimeType || 'audio/webm';
            const blob = new Blob(chatChunks, { type: finalMime });
            // send as chat-audio (separate type from first-line audio)
            sendChatAudioBlob(blob, finalMime);
            setStatus('Audio message sent!');
            $('#audio-send-btn').textContent = 'üéôÔ∏è Audio';
          };
          chatRecorder.start(100);
          $('#audio-send-btn').textContent = '‚èπÔ∏è Stop';
          setStatus('Recording audio message‚Ä¶');
        }).catch(e=>{ alert('Mic blocked: ' + e.message); });
      } else {
        chatRecorder.stop();
      }
    });

    function showMatch(other){
      hide($('#listen-section')); hide($('#speak-section'));
      show($('#match-section'));
      $('#match-info').textContent = `Matched with ${other.name || 'Mystery'}!`;
    }
    function displayMessage(message, isSent) {
      const box = $('#chat-window');
      const d = document.createElement('div');
      d.className = 'chat-message ' + (isSent?'sent':'received');
      d.textContent = message;
      box.appendChild(d); box.scrollTop = box.scrollHeight;
    }
    function appendImg(b, sent){
      const box = $('#chat-window');
      const url = URL.createObjectURL(b);
      const d = document.createElement('div');
      d.className = 'chat-message ' + (sent?'sent':'received');
      const i = document.createElement('img');
      i.src = url; i.style.maxWidth='220px'; i.style.borderRadius='10px'; i.style.display='block';
      d.appendChild(i); box.appendChild(d); box.scrollTop = box.scrollHeight;
    }

    /********** Chunked send helpers (audio & image) **********/
    function sendAudioBlob(blob, mimeType){
      if (!(conn && conn.open)) { alert('Not connected to a partner.'); return; }
      conn.send({ type:'audio-start', mime: mimeType, size: blob.size });
      const reader = new FileReader(); let offset = 0;
      reader.onload = (e) => {
        conn.send({ type:'audio-chunk', data:new Uint8Array(e.target.result) });
        offset += e.target.result.byteLength;
        if (offset < blob.size) readNext(); else conn.send({ type:'audio-end' });
      };
      function readNext(){ reader.readAsArrayBuffer(blob.slice(offset, offset + CHUNK_SIZE)); }
      readNext();
    }

    function sendChatAudioBlob(blob, mimeType){
      if (!(conn && conn.open)) return;
      conn.send({ type:'chat-audio-start', mime: mimeType, size: blob.size });
      const reader = new FileReader(); let offset = 0;
      reader.onload = (e) => {
        conn.send({ type:'chat-audio-chunk', data:new Uint8Array(e.target.result) });
        offset += e.target.result.byteLength;
        if (offset < blob.size) readNext(); else conn.send({ type:'chat-audio-end' });
      };
      function readNext(){ reader.readAsArrayBuffer(blob.slice(offset, offset + CHUNK_SIZE)); }
      readNext();
    }

    function sendImg(blob, name){
      if (!(conn && conn.open)) return;
      conn.send({ type:'image-start', mime: blob.type, name, size: blob.size });
      const r = new FileReader(); let o = 0;
      r.onload = e => {
        conn.send({ type:'image-chunk', data:new Uint8Array(e.target.result) });
        o += e.target.result.byteLength;
        if (o < blob.size) readNext(); else conn.send({ type:'image-end' });
      };
      function readNext(){ r.readAsArrayBuffer(blob.slice(o, o + CHUNK_SIZE)); }
      readNext();
    }

    /********** Incoming data (your working pattern + chat/audio/photo) **********/
    function handleData(msg){
      if (!msg || !msg.type) return;
      switch(msg.type){
        case 'profile': remoteProfile = msg.data || {}; break;

        /* First-line audio */
        case 'audio-start':
          incomingChunks = [];
          incomingMime   = msg.mime || 'audio/webm;codecs=opus';
          incomingSize   = msg.size || 0;
          show($('#listen-section'));
          setStatus('Receiving a line‚Ä¶');
          break;
        case 'audio-chunk':
          incomingChunks.push(msg.data);
          break;
        case 'audio-end': {
          const blob = new Blob(incomingChunks, { type: incomingMime });
          playBlobInAudio(blob);
          show($('#accept-btn'));   // listener can accept after hearing
          setStatus('Line received!');
          break;
        }

        /* Chat audio */
        case 'chat-audio-start':
          rxChat = { parts: [], mime: msg.mime || 'audio/webm;codecs=opus' };
          break;
        case 'chat-audio-chunk':
          rxChat.parts.push(msg.data);
          break;
        case 'chat-audio-end': {
          const blob = new Blob(rxChat.parts, { type: rxChat.mime });
          // show playable audio bubble in chat
          const url = URL.createObjectURL(blob);
          const box = $('#chat-window');
          const wrap = document.createElement('div');
          wrap.className = 'chat-message received';
          const audio = document.createElement('audio');
          audio.controls = true; audio.src = url; audio.preload = 'metadata'; audio.style.display='block';
          wrap.appendChild(audio); box.appendChild(wrap); box.scrollTop = box.scrollHeight;
          rxChat = { parts: [], mime: 'audio/webm;codecs=opus' };
          break;
        }

        /* Accept ‚Üí show chat both sides */
        case 'accept':
          matched = true;
          showMatch(msg.data || { name:'Mystery' });
          break;

        /* Text chat */
        case 'message':
          displayMessage(msg.data, false);
          break;

        /* Photo transfer */
        case 'image-start':
          rxImage = { parts: [], mime: msg.mime || 'image/jpeg', name: msg.name || 'photo.jpg' };
          break;
        case 'image-chunk':
          rxImage.parts.push(msg.data);
          break;
        case 'image-end': {
          const blob = new Blob(rxImage.parts, { type: rxImage.mime });
          appendImg(blob, false);
          rxImage = { parts: [], mime: 'image/jpeg', name: 'photo.jpg' };
          break;
        }
      }
    }
  </script>
</body>
</html>