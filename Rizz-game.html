<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Rizzler: Drop Your Best Line</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root{--gold:#e1bf78;--blue:#064D95;--green:#06954E;--red:#c40018;--redBright:#ff1e2d;}
    body{font-family:'Montserrat',sans-serif;background:#000;color:#fff;text-align:center;padding:20px;margin:0;overflow:hidden}
    .container{max-width:640px;margin:0 auto;border:2px solid var(--gold);border-radius:15px;padding:20px;box-shadow:0 0 20px var(--gold)}
    h1{font-size:2em;color:var(--gold);margin-bottom:10px}
    h1 .rizz{color:var(--redBright);display:inline-block;animation:rizzPulse 1.4s ease-in-out infinite}
    @keyframes rizzPulse{0%{transform:scale(1)}50%{transform:scale(1.15)}100%{transform:scale(1)}}
    button{padding:12px 20px;margin:8px;font-size:1em;border:none;border-radius:22px;cursor:pointer;transition:transform .2s;background:#333;color:#fff}
    button:hover{transform:scale(1.06)}
    #enter-btn{background:var(--red);color:#fff}
    #speak-btn{background:var(--green)}
    #listen-btn{background:var(--blue)}
    #accept-btn,#send-btn,#next-btn{background:var(--red)}
    input[type="text"]{padding:10px;margin:5px;border:1px solid var(--gold);border-radius:10px;background:#222;color:#fff;width:calc(100% - 24px)}
    .hidden{display:none}
    #me-line{opacity:.95;margin:10px 0 6px}
    #status{opacity:.9;margin:8px 0 2px;min-height:1.2em}
    #audio-player{margin:16px auto;width:100%}
    #chat-window{height:260px;overflow-y:auto;border:1px solid var(--gold);border-radius:10px;padding:10px;background:#111;margin-bottom:10px;text-align:left}
    .chat-message{padding:8px 10px;margin:6px 0;border-radius:12px;max-width:85%;word-wrap:break-word;animation:slideIn .3s ease-out;display:inline-block}
    .sent{background:var(--green);margin-left:auto}
    .received{background:var(--blue);margin-right:auto}
    .toolbar{display:flex;gap:8px;align-items:center;justify-content:center;flex-wrap:wrap;margin-top:8px}
    .toolbar input[type="text"]{flex:1;min-width:180px}
    .icon-btn{background:var(--blue)}
    #live-remote{width:100%;margin-top:8px}
    @keyframes slideIn{from{transform:translateY(14px);opacity:0}to{transform:translateY(0);opacity:1}}
    body::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle,rgba(225,191,120,.1) 0%,rgba(0,0,0,0) 100%);z-index:-1}
  </style>
</head>
<body>
  <div class="container">
    <h1>Rizzler: Unleash Your <span class="rizz">Rizz</span>!</h1>

    <div id="profile-form">
      <input type="text" id="display-name" placeholder="Your display name (optional)">
      <button id="enter-btn">Enter the Game</button>
      <div id="me-line" class="hidden"></div>
      <div id="status"></div>
    </div>

    <div id="main-section" class="hidden">
      <button id="speak-btn">Speak & Rizz</button>
      <button id="listen-btn">Listen & Get Rizzed</button>
    </div>

    <div id="listen-section" class="hidden">
      <audio id="audio-player" controls crossorigin="anonymous" playsinline></audio>
      <div>
        <button id="accept-btn">Accept & Match</button>
        <button id="next-btn">Next Line</button>
      </div>
    </div>

    <div id="match-section" class="hidden">
      <h2>Match! Let the Sparks Fly!</h2>
      <p id="match-info"></p>
      <audio id="live-remote" class="hidden" controls autoplay playsinline></audio>
      <div id="chat-window"></div>
      <div class="toolbar">
        <input type="text" id="chat-input" placeholder="Type your flirty messageâ€¦">
        <button id="send-btn">Send</button>
        <input id="photo-input" class="hidden" type="file" accept="image/*" capture="environment">
        <button id="photo-btn" class="icon-btn">ðŸ“· Photo</button>
      </div>
    </div>
  </div>

  <!-- PeerJS (for WebRTC) -->
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

  <!-- App logic (ES module): imports your firebase-config.js which exports `db` -->
  <script type="module">
    /***** Imports *****/
    import { db } from './firebase-config.js';
    import {
      ref, push, set, onValue, onDisconnect, remove, update, get,
      runTransaction, serverTimestamp, query, orderByChild, equalTo,
      limitToFirst, endAt
    } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js";

    /***** Config *****/
    const QUEUE_TTL_MS = 30000;    // ticket expires after 30s
    const CLAIM_BATCH  = 8;        // check up to N candidates while claiming
    const CHUNK_SIZE   = 16 * 1024;

    /***** State *****/
    let peer, conn;
    let myPeerId = null, partnerId = null;
    let userProfile = {}, remoteProfile = null;
    let acceptedLocal = false, acceptedRemote = false;
    let liveCall = null, liveLocalStream = null;

    let mediaRecorder, recordingStream, audioChunks = [];
    let incomingChunks = [], incomingMime = 'audio/webm;codecs=opus';
    let rxImage = { parts: [], mime: 'image/jpeg', name: 'photo.jpg' };

    let myTicketRef = null, myPairRef = null;
    let requeueTimer = null;

    // Buffer recordings if not connected yet
    const pendingAudioBlobs = [];

    /***** Helpers *****/
    const $ = s => document.querySelector(s);
    function setStatus(s){ $('#status').textContent = s || ''; }
    function clearRequeueTimer(){ if(requeueTimer){ clearTimeout(requeueTimer); requeueTimer=null; } }
    function getSupportedMime(){
      const t = ['audio/webm;codecs=opus','audio/webm','audio/mp4','audio/ogg;codecs=opus'];
      for (const x of t) if (window.MediaRecorder?.isTypeSupported?.(x)) return x;
      return '';
    }
    function playBlobInAudio(blob){
      const a = $('#audio-player'); const url = URL.createObjectURL(blob);
      a.srcObject=null; a.src=url; a.load(); a.play().catch(()=>{});
    }
    function isFresh(ts){ return !ts || (Date.now() - ts) < QUEUE_TTL_MS; }
    function safeRemove(r){ try{ r && remove(r); }catch{} }

    // Robust conversion of received chunk payloads â†’ Uint8Array
    function toUint8(data){
      if (data instanceof ArrayBuffer) return new Uint8Array(data);
      if (ArrayBuffer.isView(data)) return new Uint8Array(data.buffer);
      if (data && data.data && Array.isArray(data.data)) return new Uint8Array(data.data); // Node-style
      // As a last resort, try Blob
      if (data instanceof Blob) return new Uint8Array(); // we'll never send raw Blob here
      return new Uint8Array();
    }

    /***** Matchmaking (Realtime Database) *****/
    function joinQueue(){
      setStatus('Finding a random matchâ€¦');

      // 1) create my ticket
      myTicketRef = push(ref(db, 'queue'));
      set(myTicketRef, { peer: myPeerId, claimed: false, ts: serverTimestamp() });
      onDisconnect(myTicketRef).remove();

      // 2) watch if someone pairs us
      myPairRef = ref(db, 'pairs/'+myPeerId);
      onDisconnect(myPairRef).remove();
      onValue(myPairRef, (snap)=>{
        const v = snap.val();
        if (v?.partner && !partnerId) {
          partnerId = v.partner;
          clearRequeueTimer();
          setStatus('Matched! Connectingâ€¦');
          connectToPartner();
        }
      });

      // 3) cleanup stale tickets then attempt to claim a partner
      cleanupStaleTickets(() => { importCandidatesAndClaim(); });

      // 4) auto re-queue if unmatched after TTL
      clearRequeueTimer();
      requeueTimer = setTimeout(() => {
        if (!partnerId) {
          setStatus('No match yet. Re-queuingâ€¦');
          safeRemove(myTicketRef);
          safeRemove(myPairRef);
          joinQueue();
        }
      }, QUEUE_TTL_MS);
    }

    function importCandidatesAndClaim(){
      const q = query(ref(db, 'queue'), orderByChild('claimed'), equalTo(false), limitToFirst(CLAIM_BATCH));
      get(q).then((snap)=>{
        const cands = [];
        snap.forEach(cs=>{
          const v = cs.val();
          if (v && v.peer && v.peer !== myPeerId && isFresh(v.ts)) {
            cands.push({ key: cs.key, peer: v.peer, ts: v.ts });
          }
        });
        tryClaim(cands, 0);
      });
    }

    function tryClaim(list, i){
      if (partnerId || i >= list.length) { setStatus('Waiting for someoneâ€¦'); return; }
      const cand = list[i];
      const claimPath = ref(db, `queue/${cand.key}/claimed`);
      runTransaction(claimPath, cur => cur === false ? myPeerId : cur)
        .then(res=>{
          if (res.committed && res.snapshot.val() === myPeerId) {
            const updates = {};
            updates[`pairs/${myPeerId}`] = { partner: cand.peer, ts: Date.now() };
            updates[`pairs/${cand.peer}`] = { partner: myPeerId, ts: Date.now() };
            updates[`queue/${myTicketRef.key}`] = null;
            updates[`queue/${cand.key}`] = null;
            update(ref(db), updates).then(()=>{
              partnerId = cand.peer;
              clearRequeueTimer();
              setStatus('Matched! Connectingâ€¦');
              connectToPartner();
            });
          } else {
            tryClaim(list, i+1);
          }
        })
        .catch(()=> tryClaim(list, i+1));
    }

    function cleanupStaleTickets(done){
      const cutoff = Date.now() - QUEUE_TTL_MS;
      const q = query(ref(db, 'queue'), orderByChild('ts'), endAt(cutoff), limitToFirst(25));
      get(q).then((snap)=>{
        const updates = {};
        snap.forEach(cs=>{
          const v = cs.val();
          if (v && v.ts && v.ts < cutoff) updates[`queue/${cs.key}`] = null;
        });
        if (Object.keys(updates).length) update(ref(db), updates).finally(()=>done && done());
        else done && done();
      });
    }

    /***** PeerJS (WebRTC) *****/
    async function initPeer(){
      peer = new Peer(undefined,{
        debug:2,
        config:{ iceServers:[
          {urls:'stun:stun.l.google.com:19302'},
          {urls:'stun:stun1.l.google.com:19302'},
          {urls:'stun:stun2.l.google.com:19302'}
        ]}
      });

      peer.on('open', id => {
        myPeerId = id;
        $('#me-line').classList.remove('hidden');
        $('#me-line').textContent = `Your ID: ${id}`;
        joinQueue();
      });

      // inbound data channel
      peer.on('connection', (connection)=>{
        conn = connection;
        wireConn(conn);
        if (conn.open) conn.send({ type:'profile', data:userProfile });
      });

      // inbound media call
      peer.on('call', async (call)=>{
        try{
          const s = await navigator.mediaDevices.getUserMedia({ audio:true });
        liveLocalStream = s;
          call.answer(s);
          liveCall = call;
          call.on('stream', attachRemoteLive);
          call.on('close', onPartnerDisconnected);
          call.on('error', onPartnerDisconnected);
        }catch(e){ console.error('Mic error answering call:', e); }
      });

      peer.on('disconnected', ()=>{ try{peer.reconnect();}catch{} });
      peer.on('error', e => console.error('Peer error:', e));
    }

    function connectToPartner(){
      try{
        conn = peer.connect(partnerId, { reliable:true });
        wireConn(conn);
      }catch(e){ setStatus('Failed to connect to partner.'); }
    }

    function wireConn(c){
      c.on('open', () => {
        setStatus('Connected! Drop your best line.');
        $('#profile-form').classList.add('hidden');
        $('#main-section').classList.remove('hidden');
        c.send({ type:'profile', data:userProfile });

        // Flush any recordings queued before connection
        while (pendingAudioBlobs.length) {
          const { blob, mime } = pendingAudioBlobs.shift();
          reallySendAudio(blob, mime);
        }
      });
      c.on('data', handleData);
      c.on('close', onPartnerDisconnected);
      c.on('error', onPartnerDisconnected);
    }

    function onPartnerDisconnected(){
      setStatus('Partner disconnected. Re-queuingâ€¦');
      cleanupLiveCall();
      partnerId = null; acceptedLocal = false; acceptedRemote = false;
      $('#listen-section').classList.add('hidden');
      $('#match-section').classList.add('hidden');
      $('#main-section').classList.remove('hidden');
      clearRequeueTimer();
      joinQueue();
    }

    /***** UI *****/
    $('#enter-btn').addEventListener('click', async () => {
      userProfile.name = ($('#display-name').value || '').trim() || 'Rizzler';
      $('#profile-form').classList.add('hidden');
      $('#main-section').classList.remove('hidden');
      setStatus('Initializingâ€¦');
      await initPeer();
    });

    // Start recording immediately; buffer if not yet connected
    $('#speak-btn').addEventListener('click', () => {
      const btn = $('#speak-btn');
      btn.dataset.state === 'recording' ? stopRec() : startRec();
    });

    // Enter listen mode immediately and prime autoplay
    $('#listen-btn').addEventListener('click', () => {
      $('#main-section').classList.add('hidden');
      $('#listen-section').classList.remove('hidden');

      const a = $('#audio-player');
      a.muted = false;
      a.play().catch(()=>{});
      setStatus((conn && conn.open) ? 'Listeningâ€¦' : 'Listeningâ€¦ waiting for match');
    });

    $('#accept-btn').addEventListener('click', () => { acceptedLocal = true; acceptLine(); });
    $('#next-btn').addEventListener('click', nextLine);
    $('#send-btn').addEventListener('click', sendMsg);
    $('#photo-btn').addEventListener('click', () => $('#photo-input').click());
    $('#photo-input').addEventListener('change', e => {
      const f = e.target.files?.[0]; if (!f || !(conn && conn.open)) return;
      f.arrayBuffer().then(buf => {
        const b = new Blob([buf], { type: f.type || 'image/jpeg' });
        appendImg(b, true); sendImg(b, f.name || 'photo.jpg'); e.target.value = '';
      });
    });

    /***** Recording â†’ Send pickup line (send ArrayBuffer chunks) *****/
    function startRec(){
      navigator.mediaDevices.getUserMedia({ audio:true }).then(s=>{
        recordingStream = s;
        const mime = getSupportedMime();
        try{ mediaRecorder = new MediaRecorder(s, mime?{mimeType:mime}:{}) }catch(e){ alert('Recorder failed: '+e.message); return; }
        audioChunks = [];
        mediaRecorder.ondataavailable = e => { if (e.data && e.data.size>0) audioChunks.push(e.data); };
        mediaRecorder.onstop = async () => {
          recordingStream.getTracks().forEach(t => t.stop());
          const finalMime = mediaRecorder.mimeType || mime || 'audio/webm';
          const b = new Blob(audioChunks, { type: finalMime });

          if (conn && conn.open) {
            reallySendAudio(b, finalMime);
          } else {
            pendingAudioBlobs.push({ blob: b, mime: finalMime });
            setStatus('Recorded! Will send when matchedâ€¦');
          }

          const btn = $('#speak-btn'); btn.innerText='Speak & Rizz'; btn.dataset.state='';
        };
        mediaRecorder.start(100);
        const btn = $('#speak-btn'); btn.innerText='Stop'; btn.dataset.state='recording';
        setStatus('Recordingâ€¦');
      }).catch(e => alert('Mic denied: '+e.message));
    }
    function stopRec(){ if (mediaRecorder && mediaRecorder.state!=='inactive') mediaRecorder.stop(); }

    function reallySendAudio(blob, mimeType){
      if (!(conn && conn.open)) return;
      conn.send({ type:'audio-start', mime: mimeType, size: blob.size });
      let offset = 0;
      function pump(){
        const slice = blob.slice(offset, offset + CHUNK_SIZE);
        const reader = new FileReader();
        reader.onload = e => {
          const arrbuf = e.target.result; // ArrayBuffer
          conn.send({ type: 'audio-chunk', data: arrbuf });
          offset += CHUNK_SIZE;
          if (offset < blob.size) pump(); else { conn.send({ type:'audio-end' }); setStatus('Line sent!'); }
        };
        reader.readAsArrayBuffer(slice);
      }
      pump();
    }

    /***** Accept â†’ Live audio *****/
    function acceptLine(){
      if (!(conn && conn.open)) return;
      conn.send({ type:'accept', data:userProfile });
      showMatch(remoteProfile || userProfile);
      tryLive();
    }
    function tryLive(){
      if (!acceptedLocal || !acceptedRemote) return;
      if (!myPeerId || !partnerId) return;
      const iInitiate = myPeerId < partnerId;
      if (iInitiate) startCall();
    }
    async function startCall(){
      try{
        const s = await navigator.mediaDevices.getUserMedia({ audio:true });
        liveLocalStream = s;
        liveCall = peer.call(partnerId, s);
        liveCall.on('stream', attachRemoteLive);
        liveCall.on('close', onPartnerDisconnected);
        liveCall.on('error', onPartnerDisconnected);
      }catch(e){ console.error('Mic error placing call:', e); }
    }
    function attachRemoteLive(rs){
      const el = $('#live-remote');
      el.classList.remove('hidden');
      el.srcObject = rs;
      el.play().catch(()=>{});
    }
    function cleanupLiveCall(){
      const el = $('#live-remote');
      el.pause(); el.srcObject = null; el.classList.add('hidden');
      if (liveLocalStream){ liveLocalStream.getTracks().forEach(t=>t.stop()); liveLocalStream = null; }
      liveCall = null;
    }

    /***** Next match *****/
    function nextLine(){
      try{ conn?.close(); }catch{}
      $('#audio-player').src = '';
      cleanupLiveCall();
      remoteProfile = null; acceptedLocal = false; acceptedRemote = false;
      $('#listen-section').classList.add('hidden');
      $('#match-section').classList.add('hidden');
      $('#main-section').classList.remove('hidden');
      partnerId = null;
      clearRequeueTimer();
      joinQueue();
    }

    function showMatch(other){
      $('#listen-section').classList.add('hidden');
      $('#match-section').classList.remove('hidden');
      $('#match-info').innerHTML = `Matched with ${other.name || 'Mystery'}!`;
    }

    /***** Chat & Photos *****/
    function sendMsg(){
      const input = $('#chat-input'); const msg = input.value.trim();
      if (!msg) return;
      if (conn && conn.open) {
        conn.send({ type:'message', data: msg });
        dispMsg(msg, true); input.value='';
      } else {
        setStatus('Not connected yet â€” message not sent.');
      }
    }
    function dispMsg(m, sent){
      const box = $('#chat-window');
      const d = document.createElement('div');
      d.className = 'chat-message ' + (sent?'sent':'received');
      d.textContent = m;
      box.appendChild(d);
      box.scrollTop = box.scrollHeight;
    }
    function sendImg(blob, name){
      if (!(conn && conn.open)) return;
      let offset = 0;
      conn.send({ type:'image-start', mime: blob.type, name, size: blob.size });
      function pump(){
        const slice = blob.slice(offset, offset + CHUNK_SIZE);
        const reader = new FileReader();
        reader.onload = e => {
          conn.send({ type:'image-chunk', data: e.target.result }); // ArrayBuffer
          offset += CHUNK_SIZE;
          if (offset < blob.size) pump(); else conn.send({ type:'image-end' });
        };
        reader.readAsArrayBuffer(slice);
      }
      pump();
    }
    function appendImg(b, sent){
      const box = $('#chat-window');
      const url = URL.createObjectURL(b);
      const d = document.createElement('div');
      d.className = 'chat-message ' + (sent?'sent':'received');
      const i = document.createElement('img');
      i.src = url; i.style.maxWidth='220px'; i.style.borderRadius='10px'; i.style.display='block';
      d.appendChild(i); box.appendChild(d); box.scrollTop = box.scrollHeight;
    }

    /***** Incoming data *****/
    function handleData(msg){
      if (!msg || !msg.type) return;
      switch(msg.type){
        case 'profile':
          remoteProfile = msg.data || null;
          break;

        case 'audio-start':
          incomingChunks=[]; incomingMime=msg.mime || 'audio/webm;codecs=opus';
          setStatus('Receiving lineâ€¦');
          break;

        case 'audio-chunk': {
          // msg.data is an ArrayBuffer (or similar) â€” normalize
          const u8 = toUint8(msg.data);
          if (u8.length) incomingChunks.push(u8);
          break;
        }

        case 'audio-end': {
          const blob = new Blob(incomingChunks, { type: incomingMime });
          playBlobInAudio(blob);
          setStatus('Line received!');
          break;
        }

        case 'accept':
          acceptedRemote = true; showMatch(remoteProfile || {}); tryLive();
          break;

        case 'message':
          dispMsg(msg.data, false);
          break;

        case 'image-start':
          rxImage={parts:[],mime:msg.mime||'image/jpeg',name:msg.name||'photo.jpg'};
          break;

        case 'image-chunk': {
          const u8 = toUint8(msg.data);
          if (u8.length) rxImage.parts.push(u8);
          break;
        }

        case 'image-end': {
          const blob = new Blob(rxImage.parts,{type:rxImage.mime});
          appendImg(blob, false);
          rxImage={parts:[],mime:'image/jpeg',name:'photo.jpg'};
          break;
        }
      }
    }
  </script>
</body>
</html>