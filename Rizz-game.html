<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Rizzler: Drop Your Best Line</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --gold:#e1bf78; --blue:#064D95; --green:#06954E; --red:#c40018; --redBright:#ff1e2d;
    }
    body{font-family:'Montserrat',sans-serif;background:#000;color:#fff;text-align:center;padding:20px;margin:0;overflow:hidden}
    .container{max-width:640px;margin:0 auto;border:2px solid var(--gold);border-radius:15px;padding:20px;box-shadow:0 0 20px var(--gold)}
    h1{font-size:2em;color:var(--gold);margin-bottom:10px}
    h1 .rizz{color:var(--redBright);display:inline-block;animation:rizzPulse 1.4s ease-in-out infinite}
    @keyframes rizzPulse{
      0%{transform:scale(1)}
      50%{transform:scale(1.15)}
      100%{transform:scale(1)}
    }
    button{padding:12px 20px;margin:8px;font-size:1em;border:none;border-radius:22px;cursor:pointer;transition:transform .2s,box-shadow .2s,color .2s;background:#333;color:#fff}
    button:hover{transform:scale(1.06)}
    #enter-btn{background:var(--red);color:#fff}
    #speak-btn{background:var(--green)}
    #listen-btn{background:var(--blue)}
    #accept-btn,#send-btn,#next-btn{background:var(--red)}
    #profile-form,#listen-section,#match-section{margin-top:20px}
    input[type="text"]{padding:10px;margin:5px;border:1px solid var(--gold);border-radius:10px;background:#222;color:#fff;font-family:'Montserrat',sans-serif;width:calc(100% - 24px)}
    #me-line{opacity:.9;margin:6px 0 12px}
    #audio-player{margin:16px auto;width:100%}
    #chat-window{height:260px;overflow-y:auto;border:1px solid var(--gold);border-radius:10px;padding:10px;background:#111;margin-bottom:10px;text-align:left}
    .chat-message{padding:8px 10px;margin:6px 0;border-radius:12px;max-width:85%;word-wrap:break-word;animation:slideIn .3s ease-out;display:inline-block}
    .sent{background:var(--green);margin-left:auto}
    .received{background:var(--blue);margin-right:auto}
    .toolbar{display:flex;gap:8px;align-items:center;justify-content:center;flex-wrap:wrap;margin-top:8px}
    .toolbar input[type="text"]{flex:1;min-width:180px}
    .icon-btn{background:var(--blue)}
    .hidden{display:none}
    #live-remote{width:100%;margin-top:8px}
    @keyframes slideIn{from{transform:translateY(14px);opacity:0}to{transform:translateY(0);opacity:1}}
    body::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle,rgba(225,191,120,.1) 0%,rgba(0,0,0,0) 100%);z-index:-1}

    /* Inline tune prompt */
    #tune-inline{margin-top:12px;border:1px dashed var(--gold);border-radius:10px;padding:10px;background:#0d0d0d}
    #tune-inline .label{display:block;margin-bottom:6px;opacity:.9}
    #tune-btn{background:var(--blue)}
    #tune-status{font-size:.9em;opacity:.8;margin-top:6px;min-height:1.2em}
    #tune-cancel{background:#444;margin-left:8px}
  </style>
</head>
<body>
  <div class="container">
    <h1>Rizzler: Unleash Your <span class="rizz">Rizz</span>!</h1>

    <!-- LOGIN / HANDLE -->
    <div id="profile-form">
      <input type="text" id="username" placeholder="Choose your username (becomes your @handle)" required>
      <input type="text" id="photo-url" placeholder="Photo URL (optional)">
      <button id="enter-btn">Enter the Game</button>
      <div id="me-line" class="hidden"></div>
    </div>

    <!-- MAIN -->
    <div id="main-section" class="hidden">
      <button id="speak-btn">Speak & Rizz</button>
      <button id="listen-btn">Listen & Get Rizzed</button>

      <!-- Inline tune prompt -->
      <div id="tune-inline" class="hidden">
        <span class="label">Enter a username/station now</span>
        <input type="text" id="target-inline" placeholder="@username or station">
        <div>
          <button id="tune-btn">Tune</button>
          <button id="tune-cancel" class="hidden">Cancel</button>
        </div>
        <div id="tune-status"></div>
      </div>
    </div>

    <!-- LISTEN (pickup line playback) -->
    <div id="listen-section" class="hidden">
      <audio id="audio-player" controls crossorigin="anonymous" playsinline></audio>
      <div>
        <button id="accept-btn">Accept & Match</button>
        <button id="next-btn">Next Line</button>
      </div>
    </div>

    <!-- MATCH: live audio + chat -->
    <div id="match-section" class="hidden">
      <h2>Match! Let the Sparks Fly!</h2>
      <p id="match-info"></p>

      <!-- Live audio room (remote) -->
      <audio id="live-remote" class="hidden" controls autoplay playsinline></audio>

      <div id="chat-window"></div>

      <div class="toolbar">
        <input type="text" id="chat-input" placeholder="Type your flirty messageâ€¦">
        <button id="send-btn">Send</button>

        <!-- Photo upload -->
        <input id="photo-input" class="hidden" type="file" accept="image/*" capture="environment">
        <button id="photo-btn" class="icon-btn">ðŸ“· Photo</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script>
    // --- Globals ---
    let peer, conn;
    let myPeerId = null;
    let userProfile = {};
    let remoteProfile = null;
    let currentPeerId = null; // who we tune to
    let remotePeerId = null;  // who is on the other end
    let matched = false;

    // Accept handshake for live audio
    let acceptedLocal = false, acceptedRemote = false;
    let liveCall = null, liveLocalStream = null;

    // Pickup line recording flow (keep working behavior)
    let mediaRecorder, recordingStream, audioChunks = [];
    let incomingChunks = [], incomingMime = 'audio/webm;codecs=opus', incomingSize = 0;

    // Image transfer buffer
    let rxImage = { parts: [], mime: 'image/jpeg', name: 'photo.jpg', size: 0 };

    // Retry tuning
    let tuneRetryTimer = null;
    let tuneRetryCount = 0;
    let tuneInProgress = false;

    // --- Username persistence ---
    function getSavedUsername(){ return localStorage.getItem('rizz_username') || ''; }
    function saveUsername(u){ localStorage.setItem('rizz_username', u); }

    // --- Toast helper ---
    function toast(msg) {
      const el = document.createElement('div');
      el.textContent = msg;
      el.style.cssText = 'position:fixed;bottom:12px;left:50%;transform:translateX(-50%);background:#222;padding:10px 14px;border:1px solid var(--gold);border-radius:10px;z-index:9999';
      document.body.appendChild(el);
      setTimeout(()=>el.remove(), 2200);
    }

    // --- Codec detection for recording ---
    function getSupportedMime() {
      const tryTypes = [
        'audio/webm;codecs=opus',
        'audio/webm',
        'audio/mp4',              // iOS Safari often supports this
        'audio/ogg;codecs=opus'
      ];
      for (const t of tryTypes) {
        if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
      }
      return '';
    }

    function playBlobInAudio(blob) {
      const audio = document.getElementById('audio-player');
      const url = URL.createObjectURL(blob);
      audio.srcObject = null;
      audio.src = url;
      audio.load();
      audio.play().catch(()=>{});
    }

    // --- Peer init with chosen username as PeerID ---
    async function initPeerWithId(desiredId) {
      return new Promise((resolve, reject) => {
        const p = new Peer(desiredId);
        p.on('open', (id) => resolve({ peer: p, id }));
        p.on('error', (err) => reject(err));
      });
    }

    async function initPeer() {
      const baseName = (getSavedUsername() || userProfile.name || '').replace(/\s+/g,'').toLowerCase();
      if (!baseName) { alert('Missing username'); return; }

      try {
        const { peer: p, id } = await initPeerWithId(baseName);
        peer = p; myPeerId = id; saveUsername(id);
      } catch (err) {
        if (err?.type === 'unavailable-id') {
          alert('That username is already in use on this network. Pick a different one.');
          // Show profile form again for quick rename
          document.getElementById('main-section').classList.add('hidden');
          const pf = document.getElementById('profile-form');
          pf.classList.remove('hidden');
          return;
        } else {
          alert('Peer error: ' + (err?.type || err));
          return;
        }
      }

      // Show handle & helper
      const me = document.getElementById('me-line');
      me.textContent = `You are live as @${myPeerId}`;
      me.classList.remove('hidden');
      toast('You are live as @' + myPeerId);

      // Incoming data connections
      peer.on('connection', (connection) => {
        conn = connection;
        remotePeerId = connection.peer;
        wireConn(conn);
        if (conn.open) conn.send({ type: 'profile', data: userProfile });
      });

      // Incoming media calls (live audio room)
      peer.on('call', async (call) => {
        try {
          const s = await navigator.mediaDevices.getUserMedia({ audio: true });
          liveLocalStream = s;
          call.answer(s);
          liveCall = call;
          call.on('stream', (remoteStream) => attachRemoteLive(remoteStream));
          call.on('close', cleanupLiveCall);
          call.on('error', cleanupLiveCall);
        } catch (e) {
          console.error('Mic error answering call:', e);
        }
      });

      peer.on('error', (e) => console.error('Peer error:', e));
    }

    function wireConn(c) {
      c.on('open', () => {
        tuneStatus('Connected to @' + (currentPeerId || c.peer));
        document.getElementById('tune-inline').classList.add('hidden');
        tuneStopRetry();
        c.send({ type: 'profile', data: userProfile });
      });
      c.on('data', handleData);
      c.on('close', () => console.log('Connection closed'));
      c.on('error', (e) => {
        console.error('Conn error:', e);
        if (e?.type === 'peer-unavailable') {
          // Will be handled by retry flow
        }
      });
    }

    // --- Inline tune UI helpers ---
    function showTuneInline() {
      const box = document.getElementById('tune-inline');
      box.classList.remove('hidden');
      document.getElementById('target-inline').focus();
      document.getElementById('tune-cancel').classList.toggle('hidden', !tuneInProgress);
    }
    function tuneStatus(msg) {
      document.getElementById('tune-status').textContent = msg || '';
    }
    function tuneStartRetry(target) {
      if (tuneInProgress) return;
      tuneInProgress = true;
      document.getElementById('tune-cancel').classList.remove('hidden');
      tuneRetryCount = 0;
      attemptConnect(target);
    }
    function tuneStopRetry() {
      tuneInProgress = false;
      document.getElementById('tune-cancel').classList.add('hidden');
      if (tuneRetryTimer) { clearTimeout(tuneRetryTimer); tuneRetryTimer = null; }
    }
    function attemptConnect(target) {
      currentPeerId = target;
      tuneStatus(`Connecting to @${target}â€¦`);
      if (conn && !conn.open) try { conn.close(); } catch {}
      conn = peer.connect(target);
      wireConn(conn);

      // Guard: if it hasnâ€™t opened within X sec, assume remote offline and retry
      const WAIT_MS = 3500;
      setTimeout(() => {
        if (!conn.open) {
          tuneRetryCount++;
          const nextIn = Math.min(3000 + tuneRetryCount*500, 8000);
          tuneStatus(`Waiting for @${target} to come onlineâ€¦ retrying in ${Math.round(nextIn/1000)}s`);
          tuneRetryTimer = setTimeout(() => attemptConnect(target), nextIn);
        }
      }, WAIT_MS);
    }

    document.getElementById('tune-btn').addEventListener('click', () => {
      const val = (document.getElementById('target-inline').value || '').replace(/^@/,'').trim();
      if (!val) { tuneStatus('Please enter a username/station.'); return; }
      showTuneInline();
      tuneStartRetry(val);
    });
    document.getElementById('tune-cancel').addEventListener('click', () => {
      tuneStopRetry();
      tuneStatus('Tuning cancelled.');
    });

    // --- Ensure a connection; if no target, reveal inline tune prompt (no alerts) ---
    function ensureConnectionForSending() {
      if (conn && conn.open) return true;
      showTuneInline();
      return false;
    }

    // --- UI wiring ---
    document.getElementById('enter-btn').addEventListener('click', async () => {
      const nameInput = document.getElementById('username');
      const photoInput = document.getElementById('photo-url');

      let desiredUsername = nameInput.value.trim() || getSavedUsername();
      if (!desiredUsername) { alert('Choose a username'); return; }

      userProfile.name = desiredUsername;  // username doubles as display name
      userProfile.photo = photoInput.value.trim() || 'No photo';

      document.getElementById('profile-form').classList.add('hidden');
      document.getElementById('main-section').classList.remove('hidden');

      await initPeer();

      // Auto-open tune prompt so itâ€™s obvious
      showTuneInline();

      // Deep-link support: ?to=username
      const params = new URLSearchParams(location.search);
      const to = (params.get('to') || '').replace(/^@/,'');
      if (to) {
        document.getElementById('target-inline').value = to;
        tuneStatus('');
      }
    });

    document.getElementById('speak-btn').addEventListener('click', () => {
      // If not connected yet, show inline prompt instead of proceeding
      if (!ensureConnectionForSending()) return;
      const btn = document.getElementById('speak-btn');
      if (btn.dataset.state === 'recording') stopRecording();
      else startRecording();
    });

    document.getElementById('listen-btn').addEventListener('click', () => {
      // Always allow user to tune here if not connected yet
      if (!ensureConnectionForSending()) return;
      startListening();
    });

    document.getElementById('accept-btn').addEventListener('click', acceptLine);
    document.getElementById('next-btn').addEventListener('click', nextLine);
    document.getElementById('send-btn').addEventListener('click', sendMessage);
    document.getElementById('photo-btn').addEventListener('click', () => {
      document.getElementById('photo-input').click();
    });
    document.getElementById('photo-input').addEventListener('change', handlePhotoChosen);

    // --- Pickup line record â†’ send (kept working behavior) ---
    function startRecording() {
      navigator.mediaDevices.getUserMedia({ audio: true }).then((s) => {
        recordingStream = s;
        const mimeType = getSupportedMime();
        try { mediaRecorder = new MediaRecorder(recordingStream, mimeType ? { mimeType } : {}); }
        catch (e) { alert('MediaRecorder failed to start: ' + e.message); return; }

        audioChunks = [];
        mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size > 0) audioChunks.push(e.data); };
        mediaRecorder.onstop = () => {
          recordingStream.getTracks().forEach(t => t.stop());
          const finalMime = mediaRecorder.mimeType || mimeType || 'audio/webm';
          const blob = new Blob(audioChunks, { type: finalMime });
          sendPickupBlob(blob, finalMime);
          const btn = document.getElementById('speak-btn');
          btn.innerText = 'Speak & Rizz';
          btn.dataset.state = '';
        };

        mediaRecorder.start(100);
        const btn = document.getElementById('speak-btn');
        btn.innerText = 'Stop';
        btn.dataset.state = 'recording';
      }).catch((e) => alert('Microphone access denied: ' + e.message));
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
    }

    function sendPickupBlob(blob, mimeType) {
      if (!(conn && conn.open)) return;
      conn.send({ type: 'audio-start', mime: mimeType, size: blob.size });
      const chunkSize = 16 * 1024;
      let offset = 0;
      const reader = new FileReader();
      reader.onload = (e) => {
        conn.send({ type: 'audio-chunk', data: new Uint8Array(e.target.result) });
        offset += e.target.result.byteLength;
        if (offset < blob.size) readNext(); else conn.send({ type: 'audio-end' });
      };
      function readNext(){ reader.readAsArrayBuffer(blob.slice(offset, offset + chunkSize)); }
      readNext();
    }

    // --- Listening to pickup lines (view switch only; connection already handled by tuning) ---
    function startListening() {
      document.getElementById('main-section').classList.add('hidden');
      document.getElementById('listen-section').classList.remove('hidden');
    }

    // --- Accept -> Live audio room handshake ---
    function acceptLine() {
      if (!(conn && conn.open)) return;
      acceptedLocal = true;
      conn.send({ type: 'accept', data: userProfile });
      showMatch(remoteProfile || userProfile);
      tryStartLiveRoom();
    }

    function tryStartLiveRoom() {
      if (!acceptedLocal || !acceptedRemote) return;
      if (!myPeerId || !remotePeerId) return;
      // Avoid double call â€” lexicographically smaller PeerID initiates
      const iInitiate = myPeerId < remotePeerId;
      if (iInitiate) startOutgoingLiveCall();
      // other side auto-answers in peer.on('call')
    }

    async function startOutgoingLiveCall() {
      try {
        const s = await navigator.mediaDevices.getUserMedia({ audio: true });
        liveLocalStream = s;
        liveCall = peer.call(remotePeerId, s);
        liveCall.on('stream', (remoteStream) => attachRemoteLive(remoteStream));
        liveCall.on('close', cleanupLiveCall);
        liveCall.on('error', cleanupLiveCall);
      } catch (e) {
        console.error('Mic error placing call:', e);
      }
    }

    function attachRemoteLive(remoteStream) {
      const el = document.getElementById('live-remote');
      el.classList.remove('hidden');
      el.srcObject = remoteStream;
      el.play().catch(()=>{});
    }

    function cleanupLiveCall() {
      const el = document.getElementById('live-remote');
      el.pause(); el.srcObject = null; el.classList.add('hidden');
      if (liveLocalStream) { liveLocalStream.getTracks().forEach(t=>t.stop()); liveLocalStream = null; }
      liveCall = null;
    }

    function nextLine() {
      if (conn) try { conn.close(); } catch {}
      document.getElementById('audio-player').srcObject = null;
      document.getElementById('audio-player').src = '';
      cleanupLiveCall();
      remoteProfile = null;
      acceptedLocal = false; acceptedRemote = false; matched = false;
      // go back to main to choose again
      document.getElementById('listen-section').classList.add('hidden');
      document.getElementById('main-section').classList.remove('hidden');
      // show tuner to pick another target
      showTuneInline();
    }

    function showMatch(otherProfile) {
      document.getElementById('listen-section').classList.add('hidden');
      document.getElementById('match-section').classList.remove('hidden');
      const matchInfo = document.getElementById('match-info');
      matchInfo.innerHTML = `Matched with ${otherProfile.name}! ${
        otherProfile.photo !== 'No photo'
          ? `<br><img src="${otherProfile.photo}" alt="Profile Photo" style="max-width: 150px; border-radius: 50%; border: 2px solid var(--gold);">`
          : ''
      }`;
    }

    // --- Text chat (auto shows on both ends) ---
    function sendMessage() {
      const input = document.getElementById('chat-input');
      const message = input.value.trim();
      if (!message || !(conn && conn.open)) return;
      conn.send({ type: 'message', data: message });
      displayMessage(message, true);   // local bubble
      input.value = '';
    }

    function displayMessage(message, isSent) {
      const chatWindow = document.getElementById('chat-window');
      const messageDiv = document.createElement('div');
      messageDiv.className = `chat-message ${isSent ? 'sent' : 'received'}`;
      messageDiv.textContent = message;
      chatWindow.appendChild(messageDiv);
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    // --- Photo sending (chunked) ---
    function handlePhotoChosen(e) {
      const file = e.target.files && e.target.files[0];
      if (!file || !(conn && conn.open)) return;

      file.arrayBuffer().then(buf => {
        const blob = new Blob([buf], { type: file.type || 'image/jpeg' });
        appendImage(blob, true);              // local echo
        sendImageBlob(blob, file.name || 'photo.jpg');
        e.target.value = '';
      });
    }

    function sendImageBlob(blob, name) {
      if (!(conn && conn.open)) return;
      conn.send({ type: 'image-start', mime: blob.type, name, size: blob.size });
      const chunkSize = 16 * 1024;
      let offset = 0;
      const reader = new FileReader();
      reader.onload = (e) => {
        conn.send({ type: 'image-chunk', data: new Uint8Array(e.target.result) });
        offset += e.target.result.byteLength;
        if (offset < blob.size) readNext(); else conn.send({ type: 'image-end' });
      };
      function readNext(){ reader.readAsArrayBuffer(blob.slice(offset, offset + chunkSize)); }
      readNext();
    }

    function appendImage(blob, sent) {
      const chatWindow = document.getElementById('chat-window');
      const url = URL.createObjectURL(blob);
      const wrap = document.createElement('div');
      wrap.className = `chat-message ${sent ? 'sent' : 'received'}`;
      const img = document.createElement('img');
      img.src = url;
      img.style.maxWidth = '220px';
      img.style.borderRadius = '10px';
      img.style.display = 'block';
      wrap.appendChild(img);
      chatWindow.appendChild(wrap);
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    // --- Incoming data handler (profiles, audio chunks, accept, text, images) ---
    function handleData(msg) {
      if (!msg || !msg.type) return;

      switch (msg.type) {
        case 'profile':
          remoteProfile = msg.data || null;
          remotePeerId = conn?.peer || remotePeerId;
          break;

        // pickup line receive (kept working)
        case 'audio-start':
          incomingChunks = []; incomingMime = msg.mime || 'audio/webm;codecs=opus'; incomingSize = msg.size || 0;
          break;
        case 'audio-chunk':
          incomingChunks.push(msg.data);
          break;
        case 'audio-end': {
          const blob = new Blob(incomingChunks, { type: incomingMime });
          playBlobInAudio(blob);
          break;
        }

        // accept handshake (live audio room)
        case 'accept':
          acceptedRemote = true;
          matched = true;
          if (msg.data) remoteProfile = msg.data;
          showMatch(remoteProfile || { name: 'Mystery' });
          tryStartLiveRoom();
          break;

        // text chat (auto shows here)
        case 'message':
          if (matched) displayMessage(msg.data, false);
          break;

        // image receive
        case 'image-start':
          rxImage = { parts: [], mime: msg.mime || 'image/jpeg', name: msg.name || 'photo.jpg', size: msg.size || 0 };
          break;
        case 'image-chunk':
          rxImage.parts.push(msg.data);
          break;
        case 'image-end': {
          const blob = new Blob(rxImage.parts, { type: rxImage.mime });
          appendImage(blob, false);
          rxImage = { parts: [], mime: 'image/jpeg', name: 'photo.jpg', size: 0 };
          break;
        }

        default:
          console.log('Unknown message type:', msg.type);
      }
    }
  </script>
</body>
</html>